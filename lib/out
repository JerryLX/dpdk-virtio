./librte_ether/rte_ethdev.h: *	The user data is overwritten with struct rte_pmd_ixgbe_mb_event_param.
./librte_ether/rte_ethdev.h: *	This struct is defined in rte_pmd_ixgbe.h.
./librte_ether/rte_ethdev.h: *   i40e. Unused in igb/ixgbe, pass 0 instead.
./librte_eal/common/include/rte_eal.h: * The no-huge mode cannot be used with UIO poll-mode drivers like igb/ixgbe.
Binary file ./librte_eal/linuxapp/eal/.eal.c.swp matches
./librte_eal/linuxapp/kni/ethtool/README:drivers of ixgbe/igb are needed to be reused here. ixgbe-3.9.17 is the version
./librte_eal/linuxapp/kni/ethtool/README:modified from in kernel NIC interface kernel module to support ixgbe NIC, and
./librte_eal/linuxapp/kni/ethtool/README:The source code package of ixgbe can be downloaded from sourceforge.net as below.
./librte_eal/linuxapp/kni/ethtool/README:http://sourceforge.net/projects/e1000/files/ixgbe%20stable/
./librte_eal/linuxapp/kni/ethtool/README:Below source files are copied or modified from ixgbe.
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_82598.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_82599.c
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_82599.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_api.c
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_api.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_common.c
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_common.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_dcb.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_ethtool.c
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_fcoe.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_main.c
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_mbx.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_osdep.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_phy.c
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_phy.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_sriov.h
./librte_eal/linuxapp/kni/ethtool/README:ixgbe_type.h
./librte_eal/linuxapp/kni/ethtool/igb/kcompat.h: * Node module parameter of ixgbe.
./librte_eal/linuxapp/kni/ethtool/igb/kcompat.h:#undef ixgbe_get_netdev_tc_txq
./librte_eal/linuxapp/kni/ethtool/igb/kcompat.h:#define ixgbe_get_netdev_tc_txq(dev, tc) (&netdev_extended(dev)->qos_data.tc_to_txq[tc])
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:struct ixgbe_dcb_support {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:enum ixgbe_dcb_tsa {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_tsa_ets = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_tsa_group_strict_cee,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_tsa_strict
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:struct ixgbe_dcb_tc_path {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	enum ixgbe_dcb_tsa tsa; /* Link or Group Strict Priority */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:enum ixgbe_dcb_pfc {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_pfc_disabled = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_pfc_enabled,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_pfc_enabled_txonly,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_pfc_enabled_rxonly
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:struct ixgbe_dcb_tc_config {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	struct ixgbe_dcb_tc_path path[2]; /* One each for Tx/Rx */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	enum ixgbe_dcb_pfc pfc; /* Class based flow control setting */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:enum ixgbe_dcb_pba {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_pba_equal = PBA_STRATEGY_EQUAL,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	ixgbe_dcb_pba_80_48 = PBA_STRATEGY_WEIGHTED
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:struct ixgbe_dcb_num_tcs {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:struct ixgbe_dcb_config {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	struct ixgbe_dcb_tc_config tc_config[IXGBE_DCB_MAX_TRAFFIC_CLASS];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	struct ixgbe_dcb_support support;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	struct ixgbe_dcb_num_tcs num_tcs;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:	enum ixgbe_dcb_pba rx_pba_cfg;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_check_config_cee(struct ixgbe_dcb_config *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_calculate_tc_credits(u8 *, u16 *, u16 *, int);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_calculate_tc_credits_cee(struct ixgbe_hw *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:				       struct ixgbe_dcb_config *, u32, u8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_config_pfc(struct ixgbe_hw *, u8, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_config_pfc_cee(struct ixgbe_hw *, struct ixgbe_dcb_config *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_config_tc_stats(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_get_tc_stats(struct ixgbe_hw *, struct ixgbe_hw_stats *, u8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_get_pfc_stats(struct ixgbe_hw *, struct ixgbe_hw_stats *, u8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_config_tx_desc_arbiter_cee(struct ixgbe_hw *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:					 struct ixgbe_dcb_config *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_config_tx_data_arbiter_cee(struct ixgbe_hw *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:					 struct ixgbe_dcb_config *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_config_rx_arbiter_cee(struct ixgbe_hw *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:				    struct ixgbe_dcb_config *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:void ixgbe_dcb_unpack_pfc_cee(struct ixgbe_dcb_config *, u8 *, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:void ixgbe_dcb_unpack_refill_cee(struct ixgbe_dcb_config *, int, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:void ixgbe_dcb_unpack_max_cee(struct ixgbe_dcb_config *, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:void ixgbe_dcb_unpack_bwgid_cee(struct ixgbe_dcb_config *, int, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:void ixgbe_dcb_unpack_tsa_cee(struct ixgbe_dcb_config *, int, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:void ixgbe_dcb_unpack_map_cee(struct ixgbe_dcb_config *, int, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_hw_config(struct ixgbe_hw *, u16 *, u16 *, u8 *, u8 *, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_dcb.h:s32 ixgbe_dcb_hw_config_cee(struct ixgbe_hw *, struct ixgbe_dcb_config *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:				      ixgbe_link_speed *speed, bool *autoneg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:					  ixgbe_link_speed speed, bool autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:				    ixgbe_link_speed speed, bool autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw, ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:u32 ixgbe_get_supported_physical_layer_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.h:bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:#include "ixgbe_82598.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:#include "ixgbe_api.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:#include "ixgbe_common.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:#include "ixgbe_phy.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:					     ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:				      ixgbe_link_speed *speed, bool *link_up,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:				      ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:					 ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_set_pcie_completion_timeout - set pci-e completion timeout
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_init_ops_82598 - Inits func ptrs and MAC type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_init_ops_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	struct ixgbe_phy_info *phy = &hw->phy;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ret_val = ixgbe_init_phy_ops_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ret_val = ixgbe_init_ops_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	phy->ops.init = &ixgbe_init_phy_ops_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.start_hw = &ixgbe_start_hw_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.reset_hw = &ixgbe_reset_hw_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.get_media_type = &ixgbe_get_media_type_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:				&ixgbe_get_supported_physical_layer_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.read_analog_reg8 = &ixgbe_read_analog_reg8_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.write_analog_reg8 = &ixgbe_write_analog_reg8_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.set_lan_id = &ixgbe_set_lan_id_multi_port_pcie_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.set_vmdq = &ixgbe_set_vmdq_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.clear_vmdq = &ixgbe_clear_vmdq_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.set_vfta = &ixgbe_set_vfta_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.clear_vfta = &ixgbe_clear_vfta_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.fc_enable = &ixgbe_fc_enable_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->max_msix_vectors	= ixgbe_get_pcie_msix_count_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	phy->ops.read_i2c_eeprom = &ixgbe_read_i2c_eeprom_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.check_link = &ixgbe_check_mac_link_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.setup_link = &ixgbe_setup_mac_link_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.get_link_capabilities = &ixgbe_get_link_capabilities_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	mac->ops.setup_rxpba = &ixgbe_set_rxpba_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_init_phy_ops_82598 - PHY/SFP specific init
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	struct ixgbe_phy_info *phy = &hw->phy;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		mac->ops.setup_link = &ixgbe_setup_copper_link_82598;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:				&ixgbe_get_copper_link_capabilities_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_phy_tn:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		phy->ops.setup_link = &ixgbe_setup_phy_link_tnx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		phy->ops.check_link = &ixgbe_check_phy_link_tnx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:					&ixgbe_get_phy_firmware_version_tnx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_phy_nl:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		phy->ops.reset = &ixgbe_reset_phy_nl;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		else if (hw->phy.sfp_type == ixgbe_sfp_type_unknown) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_start_hw_82598 - Prepare hardware for Tx/Rx
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ret_val = ixgbe_start_hw_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		ixgbe_set_pcie_completion_timeout(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_get_link_capabilities_82598 - Determines link capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_get_link_capabilities_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:					     ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_get_media_type_82598 - Determines media type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static enum ixgbe_media_type ixgbe_get_media_type_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	enum ixgbe_media_type media_type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_phy_cu_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_phy_tn:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		media_type = ixgbe_media_type_copper;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		media_type = ixgbe_media_type_backplane;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		media_type = ixgbe_media_type_fiber;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		media_type = ixgbe_media_type_cx4;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		media_type = ixgbe_media_type_copper;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		media_type = ixgbe_media_type_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_fc_enable_82598 - Enable flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		case ixgbe_fc_full:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:			hw->fc.requested_mode = ixgbe_fc_tx_pause;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		case ixgbe_fc_rx_pause:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:			hw->fc.requested_mode = ixgbe_fc_none;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ixgbe_fc_autoneg(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_fc_none:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_fc_rx_pause:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_fc_tx_pause:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_fc_full:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_start_mac_link_82598 - Configures MAC link settings
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  Configures link settings based on values in the ixgbe_hw struct.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_start_mac_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_validate_link_ready - Function looks for phy link
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_validate_link_ready(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_check_mac_link_82598 - Get link/speed status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_check_mac_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:				      ixgbe_link_speed *speed, bool *link_up,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	if (hw->phy.type == ixgbe_phy_nl) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	    (ixgbe_validate_link_ready(hw) != 0))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_setup_mac_link_82598 - Set MAC link speed
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_setup_mac_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:				      ixgbe_link_speed speed, bool autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ixgbe_get_link_capabilities(hw, &link_capabilities, &autoneg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		 * ixgbe_hw This will write the AUTOC register based on the new
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		status = ixgbe_start_mac_link_82598(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_setup_copper_link_82598 - Set the PHY autoneg advertised field
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_setup_copper_link_82598(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:					 ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ixgbe_start_mac_link_82598(hw, autoneg_wait_to_complete);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_reset_hw_82598 - Performs hardware reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_reset_hw_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_set_vmdq_82598 - Associate a VMDq set index with a rx address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_clear_vmdq_82598 - Disassociate a VMDq set index from an rx address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_clear_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_set_vfta_82598 - Set VLAN filter table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_clear_vfta_82598 - Clear VLAN filter table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static s32 ixgbe_clear_vfta_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_read_analog_reg8_82598 - Reads 8 bit Atlas analog register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_write_analog_reg8_82598 - Writes 8 bit Atlas analog register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_read_i2c_eeprom_82598 - Reads 8 bit word over I2C interface.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	if (hw->phy.type == ixgbe_phy_nl) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_get_supported_physical_layer_82598 - Returns physical layer type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:u32 ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_phy_tn:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	case ixgbe_phy_cu_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	if (hw->phy.type == ixgbe_phy_nl) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		case ixgbe_sfp_type_da_cu:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		case ixgbe_sfp_type_sr:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:		case ixgbe_sfp_type_lr:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: *  ixgbe_set_lan_id_multi_port_pcie_82598 - Set LAN id for PCIe multiple
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	struct ixgbe_bus_info *bus = &hw->bus;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:	ixgbe_set_lan_id_multi_port_pcie(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c: * ixgbe_set_rxpba_82598 - Initialize RX packet buffer
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.c:static void ixgbe_set_rxpba_82598(struct ixgbe_hw *hw, int num_pb,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:#include "ixgbe_api.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:#include "ixgbe_common.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_init_shared_code - Initialize the shared code
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  other function in the shared code. The ixgbe_hw structure should be
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_init_shared_code(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	ixgbe_set_mac_type(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		status = ixgbe_init_ops_82598(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		status = ixgbe_init_ops_82599(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		status = ixgbe_init_ops_X540(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_set_mac_type - Sets MAC type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_mac_type(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:			hw->mac.type = ixgbe_mac_82598EB;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:			hw->mac.type = ixgbe_mac_82599EB;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:			hw->mac.type = ixgbe_mac_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	hw_dbg(hw, "ixgbe_set_mac_type found mac: %d, returns: %d\n",
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_init_hw - Initialize the hardware
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_init_hw(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.init_hw, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_reset_hw - Performs a hardware reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_reset_hw(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.reset_hw, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_start_hw - Prepares hardware for Rx/Tx
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_start_hw(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.start_hw, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_clear_hw_cntrs - Clear hardware counters
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_clear_hw_cntrs(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.clear_hw_cntrs, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_media_type - Get media type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:enum ixgbe_media_type ixgbe_get_media_type(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_media_type, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:			       ixgbe_media_type_unknown);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_mac_addr - Get MAC address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_mac_addr(struct ixgbe_hw *hw, u8 *mac_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_mac_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_san_mac_addr - Get SAN MAC address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_san_mac_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_set_san_mac_addr - Write a SAN MAC address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_san_mac_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_device_caps - Get additional device capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_device_caps(struct ixgbe_hw *hw, u16 *device_caps)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_device_caps,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_wwn_prefix - Get alternative WWNN/WWPN prefix from the EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_wwn_prefix(struct ixgbe_hw *hw, u16 *wwnn_prefix,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_wwn_prefix,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_fcoe_boot_status -  Get FCOE boot status from EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_fcoe_boot_status(struct ixgbe_hw *hw, u16 *bs)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_fcoe_boot_status,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_bus_info - Set PCI bus info
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_bus_info(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_bus_info, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_num_of_tx_queues - Get Tx queues
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:u32 ixgbe_get_num_of_tx_queues(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_num_of_rx_queues - Get Rx queues
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:u32 ixgbe_get_num_of_rx_queues(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_stop_adapter - Disable Rx/Tx units
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_stop_adapter(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.stop_adapter, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_read_pba_string - Reads part number string from EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_read_pba_string(struct ixgbe_hw *hw, u8 *pba_num, u32 pba_num_size)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_read_pba_string_generic(hw, pba_num, pba_num_size);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_identify_phy - Get PHY type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_identify_phy(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	if (hw->phy.type == ixgbe_phy_unknown) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		status = ixgbe_call_func(hw, hw->phy.ops.identify, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_reset_phy - Perform a PHY reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_reset_phy(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	if (hw->phy.type == ixgbe_phy_unknown) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		if (ixgbe_identify_phy(hw) != 0)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		status = ixgbe_call_func(hw, hw->phy.ops.reset, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_phy_firmware_version -
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_phy_firmware_version(struct ixgbe_hw *hw, u16 *firmware_version)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	status = ixgbe_call_func(hw, hw->phy.ops.get_firmware_version,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_read_phy_reg - Read PHY register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_read_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		ixgbe_identify_phy(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.read_reg, (hw, reg_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_write_phy_reg - Write PHY register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_write_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:		ixgbe_identify_phy(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.write_reg, (hw, reg_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_setup_phy_link - Restart PHY autoneg
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_setup_phy_link(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.setup_link, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_check_phy_link - Determine link and speed status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_check_phy_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.check_link, (hw, speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_setup_phy_link_speed - Set auto advertise
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_setup_phy_link_speed(struct ixgbe_hw *hw, ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.setup_link_speed, (hw, speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_check_link - Get link and speed status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_check_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.check_link, (hw, speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_disable_tx_laser - Disable Tx laser
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:void ixgbe_disable_tx_laser(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_enable_tx_laser - Enable Tx laser
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:void ixgbe_enable_tx_laser(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_flap_tx_laser - flap Tx laser to start autotry process
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:void ixgbe_flap_tx_laser(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_setup_link - Set link speed
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_setup_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.setup_link, (hw, speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_link_capabilities - Returns link capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_link_capabilities(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_link_capabilities, (hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_led_on - Turn on LEDs
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_led_on(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.led_on, (hw, index),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_led_off - Turn off LEDs
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_led_off(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.led_off, (hw, index),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_blink_led_start - Blink LEDs
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_blink_led_start(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.blink_led_start, (hw, index),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_blink_led_stop - Stop blinking LEDs
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_blink_led_stop(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.blink_led_stop, (hw, index),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_init_eeprom_params - Initialize EEPROM parameters
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  Initializes the EEPROM parameters ixgbe_eeprom_info within the
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_hw struct in order to set up EEPROM access.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_init_eeprom_params(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->eeprom.ops.init_params, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_write_eeprom - Write word to EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  Writes 16 bit value to EEPROM. If ixgbe_eeprom_update_checksum is not
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_write_eeprom(struct ixgbe_hw *hw, u16 offset, u16 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->eeprom.ops.write, (hw, offset, data),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_write_eeprom_buffer - Write word(s) to EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  Writes 16 bit word(s) to EEPROM. If ixgbe_eeprom_update_checksum is not
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_write_eeprom_buffer(struct ixgbe_hw *hw, u16 offset, u16 words,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->eeprom.ops.write_buffer,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_read_eeprom - Read word from EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_read_eeprom(struct ixgbe_hw *hw, u16 offset, u16 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->eeprom.ops.read, (hw, offset, data),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_read_eeprom_buffer - Read word(s) from EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_read_eeprom_buffer(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->eeprom.ops.read_buffer,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_validate_eeprom_checksum - Validate EEPROM checksum
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_validate_eeprom_checksum(struct ixgbe_hw *hw, u16 *checksum_val)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->eeprom.ops.validate_checksum,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_eeprom_update_checksum - Updates the EEPROM checksum
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_update_eeprom_checksum(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->eeprom.ops.update_checksum, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_insert_mac_addr - Find a RAR for this mac address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_insert_mac_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.insert_mac_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_set_rar - Set Rx address register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_rar(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_rar, (hw, index, addr, vmdq,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_clear_rar - Clear Rx address register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_clear_rar(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.clear_rar, (hw, index),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_set_vmdq - Associate a VMDq index with a receive address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_vmdq, (hw, rar, vmdq),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_set_vmdq_san_mac - Associate VMDq index 127 with a receive address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_vmdq_san_mac(struct ixgbe_hw *hw, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_vmdq_san_mac,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_clear_vmdq - Disassociate a VMDq index from a receive address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_clear_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.clear_vmdq, (hw, rar, vmdq),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_init_rx_addrs - Initializes receive address filters.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_init_rx_addrs(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.init_rx_addrs, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_num_rx_addrs - Returns the number of RAR entries.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:u32 ixgbe_get_num_rx_addrs(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_update_uc_addr_list - Updates the MAC's list of secondary addresses
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_update_uc_addr_list(struct ixgbe_hw *hw, u8 *addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:			      u32 addr_count, ixgbe_mc_addr_itr func)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.update_uc_addr_list, (hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_update_mc_addr_list - Updates the MAC's list of multicast addresses
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_update_mc_addr_list(struct ixgbe_hw *hw, u8 *mc_addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:			      u32 mc_addr_count, ixgbe_mc_addr_itr func,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.update_mc_addr_list, (hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_enable_mc - Enable multicast address in RAR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_enable_mc(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.enable_mc, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_disable_mc - Disable multicast address in RAR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_disable_mc(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.disable_mc, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_clear_vfta - Clear VLAN filter table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_clear_vfta(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.clear_vfta, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_set_vfta - Set VLAN filter table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_vfta(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_vfta, (hw, vlan, vind,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_set_vlvf - Set VLAN Pool Filter
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_vlvf(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_vlvf, (hw, vlan, vind,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_fc_enable - Enable flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_fc_enable(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.fc_enable, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: * ixgbe_set_fw_drv_ver - Try to send the driver version number FW
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_set_fw_drv_ver(struct ixgbe_hw *hw, u8 maj, u8 min, u8 build,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.set_fw_drv_ver, (hw, maj, min,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_thermal_sensor_data - Gathers thermal sensor data
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_get_thermal_sensor_data(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_thermal_sensor_data, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_init_thermal_sensor_thresh - Inits thermal sensor thresholds
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_init_thermal_sensor_thresh(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.init_thermal_sensor_thresh, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_read_analog_reg8 - Reads 8 bit analog register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_read_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 *val)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.read_analog_reg8, (hw, reg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_write_analog_reg8 - Writes 8 bit analog register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_write_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 val)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.write_analog_reg8, (hw, reg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_init_uta_tables - Initializes Unicast Table Arrays.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_init_uta_tables(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.init_uta_tables, (hw),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_read_i2c_byte - Reads 8 bit word over I2C at specified device address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_read_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.read_i2c_byte, (hw, byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_write_i2c_byte - Writes 8 bit word over I2C
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_write_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.write_i2c_byte, (hw, byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_write_i2c_eeprom - Writes 8 bit EEPROM word over I2C interface
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_write_i2c_eeprom(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.write_i2c_eeprom,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_read_i2c_eeprom - Reads 8 bit EEPROM word over I2C interface
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_read_i2c_eeprom(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->phy.ops.read_i2c_eeprom,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_get_supported_physical_layer - Returns physical layer type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:u32 ixgbe_get_supported_physical_layer(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.get_supported_physical_layer,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_enable_rx_dma - Enables Rx DMA unit, dependent on device specifics
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_enable_rx_dma(struct ixgbe_hw *hw, u32 regval)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.enable_rx_dma,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_disable_sec_rx_path - Stops the receive data path
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_disable_sec_rx_path(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.disable_sec_rx_path,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_enable_sec_rx_path - Enables the receive data path
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_enable_sec_rx_path(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.enable_sec_rx_path,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_acquire_swfw_semaphore - Acquire SWFW semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:s32 ixgbe_acquire_swfw_semaphore(struct ixgbe_hw *hw, u16 mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:	return ixgbe_call_func(hw, hw->mac.ops.acquire_swfw_sync,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c: *  ixgbe_release_swfw_semaphore - Release SWFW semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.c:void ixgbe_release_swfw_semaphore(struct ixgbe_hw *hw, u16 mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_fcoe.h:struct ixgbe_fcoe_ddp {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_fcoe.h:struct ixgbe_fcoe {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_fcoe.h:	struct ixgbe_fcoe_ddp ddp[IXGBE_FCOE_DDP_MAX];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:#include "ixgbe_api.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:#include "ixgbe_common.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:#include "ixgbe_phy.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_i2c_start(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_i2c_stop(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static bool ixgbe_get_i2c_data(u32 *i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_init_phy_ops_generic - Inits PHY function ptrs
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_init_phy_ops_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	struct ixgbe_phy_info *phy = &hw->phy;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.identify = &ixgbe_identify_phy_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.reset = &ixgbe_reset_phy_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.read_reg = &ixgbe_read_phy_reg_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.write_reg = &ixgbe_write_phy_reg_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.setup_link = &ixgbe_setup_phy_link_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.setup_link_speed = &ixgbe_setup_phy_link_speed_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.get_firmware_version = ixgbe_get_phy_firmware_version_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.read_i2c_byte = &ixgbe_read_i2c_byte_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.write_i2c_byte = &ixgbe_write_i2c_byte_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.read_i2c_eeprom = &ixgbe_read_i2c_eeprom_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.write_i2c_eeprom = &ixgbe_write_i2c_eeprom_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.i2c_bus_clear = &ixgbe_i2c_bus_clear;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.identify_sfp = &ixgbe_identify_module_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->sfp_type = ixgbe_sfp_type_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	phy->ops.check_overtemp = &ixgbe_tn_check_overtemp;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_identify_phy_generic - Get physical layer module
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (hw->phy.type == ixgbe_phy_unknown) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:			if (ixgbe_validate_phy_addr(hw, phy_addr)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				ixgbe_get_phy_id(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:					ixgbe_get_phy_type_from_id(hw->phy.id);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				if (hw->phy.type == ixgbe_phy_unknown) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:							 ixgbe_phy_cu_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:							 ixgbe_phy_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_validate_phy_addr - Determines phy address is valid
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:bool ixgbe_validate_phy_addr(struct ixgbe_hw *hw, u32 phy_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_phy_id - Get the phy type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_get_phy_id(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_phy_type_from_id - Get the phy type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	enum ixgbe_phy_type phy_type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		phy_type = ixgbe_phy_tn;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		phy_type = ixgbe_phy_aq;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		phy_type = ixgbe_phy_qt;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		phy_type = ixgbe_phy_nl;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		phy_type = ixgbe_phy_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_reset_phy_generic - Performs a PHY reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (hw->phy.type == ixgbe_phy_unknown)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_identify_phy_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (status != 0 || hw->phy.type == ixgbe_phy_none)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_read_phy_reg_generic - Reads a value from a specified PHY register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_write_phy_reg_generic - Writes a value to specified PHY register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_setup_phy_link_generic - Set and restart autoneg
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_link_speed speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		hw_dbg(hw, "ixgbe_setup_phy_link_generic: time out");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_setup_phy_link_speed_generic - Sets the auto advertised capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				       ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_copper_link_capabilities_generic - Determines link capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:					       ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_check_phy_link_tnx - Determine link and speed status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *	ixgbe_setup_phy_link_tnx - Set and restart autoneg
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_link_speed speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_get_copper_link_capabilities_generic(hw, &speed, &autoneg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		hw_dbg(hw, "ixgbe_setup_phy_link_tnx: time out");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_phy_firmware_version_tnx - Gets the PHY Firmware Version
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_phy_firmware_version_generic - Gets the PHY Firmware Version
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_reset_phy_nl - Performs a PHY reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_identify_module_generic - Identifies module type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	case ixgbe_media_type_fiber:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_identify_sfp_module_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	case ixgbe_media_type_fiber_qsfp:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_identify_qsfp_module_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		hw->phy.sfp_type = ixgbe_sfp_type_not_present;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_identify_sfp_module_generic - Identifies SFP modules
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	enum ixgbe_sfp_type stored_sfp_type = hw->phy.sfp_type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		hw->phy.sfp_type = ixgbe_sfp_type_not_present;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		hw->phy.type = ixgbe_phy_sfp_unsupported;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		if (hw->mac.type == ixgbe_mac_82598EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				hw->phy.sfp_type = ixgbe_sfp_type_da_cu;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				hw->phy.sfp_type = ixgbe_sfp_type_sr;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				hw->phy.sfp_type = ixgbe_sfp_type_lr;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		} else if (hw->mac.type == ixgbe_mac_82599EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						     ixgbe_sfp_type_da_cu_core0;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						     ixgbe_sfp_type_da_cu_core1;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_sfp_type_da_act_lmt_core0;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_sfp_type_da_act_lmt_core1;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:							ixgbe_sfp_type_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						      ixgbe_sfp_type_srlr_core0;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						      ixgbe_sfp_type_srlr_core1;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_sfp_type_1g_cu_core0;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_sfp_type_1g_cu_core1;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_sfp_type_1g_sx_core0;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_sfp_type_1g_sx_core1;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				hw->phy.sfp_type = ixgbe_sfp_type_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		if (hw->phy.type != ixgbe_phy_nl) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						    ixgbe_phy_sfp_passive_tyco;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:					hw->phy.type = ixgbe_phy_sfp_ftl_active;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:					hw->phy.type = ixgbe_phy_sfp_ftl;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				hw->phy.type = ixgbe_phy_sfp_avago;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:				hw->phy.type = ixgbe_phy_sfp_intel;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						 ixgbe_phy_sfp_passive_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_phy_sfp_active_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:					hw->phy.type = ixgbe_phy_sfp_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		    !(hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		      hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0  ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		      hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:			hw->phy.type = ixgbe_phy_sfp_unsupported;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		if (hw->mac.type == ixgbe_mac_82598EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_get_device_caps(hw, &enforce_sfp);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		    !((hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		      (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		      (hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0)  ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		      (hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1))) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:			if (hw->phy.type == ixgbe_phy_sfp_intel) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:						ixgbe_phy_sfp_unsupported;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	hw->phy.sfp_type = ixgbe_sfp_type_not_present;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (hw->phy.type != ixgbe_phy_nl) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		hw->phy.type = ixgbe_phy_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_identify_qsfp_module_generic - Identifies QSFP modules
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (hw->mac.ops.get_media_type(hw) != ixgbe_media_type_fiber_qsfp) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		hw->phy.sfp_type = ixgbe_sfp_type_not_present;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_sfp_init_sequence_offsets - Provides offset of PHY init sequence
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (hw->phy.sfp_type == ixgbe_sfp_type_unknown)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (hw->phy.sfp_type == ixgbe_sfp_type_not_present)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	    (hw->phy.sfp_type == ixgbe_sfp_type_da_cu))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (sfp_type == ixgbe_sfp_type_da_act_lmt_core0 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	    sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	    sfp_type == ixgbe_sfp_type_1g_sx_core0)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		sfp_type = ixgbe_sfp_type_srlr_core0;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	else if (sfp_type == ixgbe_sfp_type_da_act_lmt_core1 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		 sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		 sfp_type == ixgbe_sfp_type_1g_sx_core1)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		sfp_type = ixgbe_sfp_type_srlr_core1;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_read_i2c_eeprom_generic - Reads 8 bit EEPROM word over I2C interface
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_write_i2c_eeprom_generic - Writes 8 bit EEPROM word over I2C interface
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_read_i2c_byte_generic - Reads 8 bit word over I2C
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_i2c_start(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_byte(hw, dev_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_get_i2c_ack(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_byte(hw, byte_offset);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_get_i2c_ack(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_i2c_start(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_byte(hw, (dev_addr | 0x1));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_get_i2c_ack(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_in_i2c_byte(hw, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_bit(hw, nack);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_i2c_stop(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_i2c_bus_clear(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_write_i2c_byte_generic - Writes 8 bit word over I2C
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_i2c_start(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_byte(hw, dev_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_get_i2c_ack(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_byte(hw, byte_offset);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_get_i2c_ack(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_byte(hw, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_get_i2c_ack(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_i2c_stop(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_i2c_bus_clear(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_i2c_start - Sets I2C start condition
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_i2c_start(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_set_i2c_data(hw, &i2cctl, 1);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_raise_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_set_i2c_data(hw, &i2cctl, 0);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_lower_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_i2c_stop - Sets I2C stop condition
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_i2c_stop(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_set_i2c_data(hw, &i2cctl, 0);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_raise_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_set_i2c_data(hw, &i2cctl, 1);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_clock_in_i2c_byte - Clocks in one byte via I2C
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_in_i2c_byte(struct ixgbe_hw *hw, u8 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_clock_in_i2c_bit(hw, &bit);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_clock_out_i2c_byte - Clocks out one byte via I2C
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_out_i2c_byte(struct ixgbe_hw *hw, u8 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		status = ixgbe_clock_out_i2c_bit(hw, bit);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_i2c_ack - Polls for I2C ACK
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_get_i2c_ack(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_raise_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ack = ixgbe_get_i2c_data(&i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_lower_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_clock_in_i2c_bit - Clocks in one bit via I2C data/clock
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_in_i2c_bit(struct ixgbe_hw *hw, bool *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_raise_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	*data = ixgbe_get_i2c_data(&i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_lower_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_clock_out_i2c_bit - Clocks in/out one bit via I2C data/clock
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_clock_out_i2c_bit(struct ixgbe_hw *hw, bool data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	status = ixgbe_set_i2c_data(hw, &i2cctl, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_raise_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_lower_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_raise_i2c_clk - Raises the I2C SCL clock
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_raise_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_lower_i2c_clk - Lowers the I2C SCL clock
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static void ixgbe_lower_i2c_clk(struct ixgbe_hw *hw, u32 *i2cctl)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_set_i2c_data - Sets the I2C data bit
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static s32 ixgbe_set_i2c_data(struct ixgbe_hw *hw, u32 *i2cctl, bool data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	if (data != ixgbe_get_i2c_data(i2cctl)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_get_i2c_data - Reads the I2C SDA data bit
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:static bool ixgbe_get_i2c_data(u32 *i2cctl)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_i2c_bus_clear - Clears the I2C bus
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_i2c_start(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_set_i2c_data(hw, &i2cctl, 1);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_raise_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:		ixgbe_lower_i2c_clk(hw, &i2cctl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_i2c_start(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:	ixgbe_i2c_stop(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c: *  ixgbe_tn_check_overtemp - Checks if an overtemp occurred.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.c:s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.c:#include "ixgbe.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.c:int ixgbe_dcb_netlink_register(void)
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.c:int ixgbe_dcb_netlink_unregister(void)
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.c:int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:/* ethtool support for ixgbe */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:#include "ixgbe.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:struct ixgbe_stats {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static const struct ixgbe_stats ixgbe_gstrings_net_stats[] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.sizeof_stat = FIELD_SIZEOF(struct ixgbe_adapter, _stat), \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.stat_offset = offsetof(struct ixgbe_adapter, _stat) \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static struct ixgbe_stats ixgbe_gstrings_stats[] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	((((struct ixgbe_adapter *)netdev_priv(netdev))->num_tx_queues + \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	 ((struct ixgbe_adapter *)netdev_priv(netdev))->num_rx_queues) * \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	  (sizeof(struct ixgbe_queue_stats) / sizeof(u64)))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:#define IXGBE_GLOBAL_STATS_LEN	ARRAY_SIZE(ixgbe_gstrings_stats)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:#define IXGBE_NETDEV_STATS_LEN	ARRAY_SIZE(ixgbe_gstrings_net_stats)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		(((struct ixgbe_adapter *)netdev_priv(netdev))->flags & \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		 (sizeof(((struct ixgbe_adapter *)0)->stats.pxonrxc) + \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		  sizeof(((struct ixgbe_adapter *)0)->stats.pxontxc) + \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		  sizeof(((struct ixgbe_adapter *)0)->stats.pxoffrxc) + \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		  sizeof(((struct ixgbe_adapter *)0)->stats.pxofftxc)) \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	((((struct ixgbe_adapter *)netdev_priv(netdev))->num_vfs) * \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static const char ixgbe_gstrings_test[][ETH_GSTRING_LEN] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:#define IXGBE_TEST_LEN	(sizeof(ixgbe_gstrings_test) / ETH_GSTRING_LEN)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:int ixgbe_get_settings(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if ((hw->phy.media_type == ixgbe_media_type_copper) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			if (hw->mac.type == ixgbe_mac_X540)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (hw->phy.media_type == ixgbe_media_type_copper) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	} else if (hw->phy.media_type == ixgbe_media_type_backplane) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_tn:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_aq:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_cu_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_qt:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_nl:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_sfp_passive_tyco:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_sfp_passive_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_sfp_ftl:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_sfp_avago:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_sfp_intel:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_sfp_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_da_cu:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_da_cu_core0:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_da_cu_core1:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_sr:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_lr:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_srlr_core0:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_srlr_core1:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_not_present:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_1g_cu_core0:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_1g_cu_core1:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_1g_sx_core0:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_1g_sx_core1:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_sfp_type_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_xaui:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_generic:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_phy_sfp_unsupported:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_settings(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if ((hw->phy.media_type == ixgbe_media_type_copper) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_get_pauseparam(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (hw->fc.current_mode == ixgbe_fc_rx_pause) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	} else if (hw->fc.current_mode == ixgbe_fc_tx_pause) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	} else if (hw->fc.current_mode == ixgbe_fc_full) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_pauseparam(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_fc_info fc = hw->fc;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if ((hw->mac.type == ixgbe_mac_82598EB) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		fc.requested_mode = ixgbe_fc_full;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		fc.requested_mode = ixgbe_fc_rx_pause;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		fc.requested_mode = ixgbe_fc_tx_pause;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		fc.requested_mode = ixgbe_fc_none;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (memcmp(&fc, &hw->fc, sizeof(struct ixgbe_fc_info))) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			ixgbe_reinit_locked(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static u32 ixgbe_get_msglevel(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_set_msglevel(struct net_device *netdev, u32 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_regs_len(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_get_regs(struct net_device *netdev, struct ethtool_regs *regs,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_get_regs_1\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_get_regs_2 0x%p\n", hw->hw_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_get_regs_3\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_get_regs_4\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_eeprom_len(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_eeprom(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ret_val = ixgbe_read_eeprom_buffer(hw, first_word, eeprom_len,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_eeprom(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret_val = ixgbe_read_eeprom(hw, first_word, &eeprom_buff[0]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret_val = ixgbe_read_eeprom(hw, last_word,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ret_val = ixgbe_write_eeprom_buffer(hw, first_word,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_update_eeprom_checksum(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_get_drvinfo(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	strlcpy(drvinfo->driver, ixgbe_driver_name, sizeof(drvinfo->driver));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	strlcpy(drvinfo->version, ixgbe_driver_version,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	drvinfo->regdump_len = ixgbe_get_regs_len(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_get_ringparam(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_ringparam(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_ring *tx_ring = NULL, *rx_ring = NULL;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			err = ixgbe_setup_tx_resources(&tx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:					ixgbe_free_tx_resources(&tx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			err = ixgbe_setup_rx_resources(&rx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:					ixgbe_free_rx_resources(&rx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ixgbe_down(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			ixgbe_free_tx_resources(adapter->tx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			ixgbe_free_rx_resources(adapter->rx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ixgbe_up(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			ixgbe_free_tx_resources(&tx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_stats_count(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_sset_count(struct net_device *netdev, int sset)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_get_ethtool_stats(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	int stat_count = sizeof(struct ixgbe_queue_stats) / sizeof(u64);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_stats 0\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ixgbe_update_stats(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_stats 1\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		p = (char *)net_stats + ixgbe_gstrings_net_stats[i].stat_offset;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		data[i] = (ixgbe_gstrings_net_stats[i].sizeof_stat ==
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		p = (char *)adapter + ixgbe_gstrings_stats[j].stat_offset;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		data[i] = (ixgbe_gstrings_stats[j].sizeof_stat ==
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_stats 2\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_stats 3\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	printk(KERN_DEBUG "ixgbe_stats 4\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_get_strings(struct net_device *netdev, u32 stringset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		memcpy(data, *ixgbe_gstrings_test,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			memcpy(p, ixgbe_gstrings_net_stats[i].stat_string,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			memcpy(p, ixgbe_gstrings_stats[i].stat_string,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_link_test(struct ixgbe_adapter *adapter, u64 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:struct ixgbe_reg_test {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static struct ixgbe_reg_test reg_test_82599[] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static struct ixgbe_reg_test reg_test_82598[] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_reg_test(struct ixgbe_adapter *adapter, u64 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_reg_test *test;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_eeprom_test(struct ixgbe_adapter *adapter, u64 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (ixgbe_validate_eeprom_checksum(&adapter->hw, NULL))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static irqreturn_t ixgbe_test_intr(int irq, void *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_intr_test(struct ixgbe_adapter *adapter, u64 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (request_irq(irq, &ixgbe_test_intr, 0, netdev->name,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	} else if (!request_irq(irq, &ixgbe_test_intr, IRQF_PROBE_SHARED,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	} else if (request_irq(irq, &ixgbe_test_intr, IRQF_SHARED,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_setup_loopback_test(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (adapter->hw.mac.type == ixgbe_mac_X540) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (hw->mac.type == ixgbe_mac_82598EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, &atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_LPBK, atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, &atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_10G, atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, &atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_1G, atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_read_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, &atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_write_analog_reg8(hw, IXGBE_ATLAS_PDN_AN, atlas);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_loopback_cleanup(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_loopback_test(struct ixgbe_adapter *adapter, u64 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	//*data = ixgbe_setup_desc_rings(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	*data = ixgbe_setup_loopback_test(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	//*data = ixgbe_run_loopback_test(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ixgbe_loopback_cleanup(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	//ixgbe_free_desc_rings(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_diag_test_count(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_diag_test(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (ixgbe_link_test(adapter, &data[4]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (ixgbe_reg_test(adapter, &data[0]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (ixgbe_eeprom_test(adapter, &data[1]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (ixgbe_intr_test(adapter, &data[2]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (ixgbe_loopback_test(adapter, &data[3]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		if (ixgbe_link_test(adapter, &data[4]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_wol_exclusion(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static void ixgbe_get_wol(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (ixgbe_wol_exclusion(adapter, wol) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_wol(struct net_device *netdev, struct ethtool_wolinfo *wol)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (ixgbe_wol_exclusion(adapter, wol))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_nway_reset(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_reinit_locked(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_phys_id(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_phys_id(struct net_device *netdev, u32 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_led_on(hw, IXGBE_LED_ON);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_led_off(hw, IXGBE_LED_ON);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_coalesce(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static bool ixgbe_update_rsc(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_coalesce(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_q_vector *q_vector;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	need_reset = ixgbe_update_rsc(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_write_eitr(q_vector);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_do_reset(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static u32 ixgbe_get_rx_csum(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_ring *ring = adapter->rx_ring[0];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_rx_csum(struct net_device *netdev, u32 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		struct ixgbe_ring *ring = adapter->rx_ring[i];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			ixgbe_do_reset(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static u32 ixgbe_get_tx_csum(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_tx_csum(struct net_device *netdev, u32 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_tso(struct net_device *netdev, u32 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_flags(struct net_device *netdev, u32 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_vlan_mode(netdev, netdev->features);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ixgbe_do_reset(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	union ixgbe_atr_input *mask = &adapter->fdir_mask;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_fdir_filter *rule = NULL;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_ethtool_fdir_all(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_fdir_filter *rule;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_rss_hash_opts(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	/* Report default options for RSS on ixgbe */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(dev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret = ixgbe_get_ethtool_fdir_entry(adapter, cmd);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret = ixgbe_get_ethtool_fdir_all(adapter, cmd,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret = ixgbe_get_rss_hash_opts(adapter, cmd);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_update_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:					   struct ixgbe_fdir_filter *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_fdir_filter *rule;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:			err = ixgbe_fdir_erase_perfect_filter_82599(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_flowspec_to_flow_type(struct ethtool_rx_flow_spec *fsp,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_add_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_fdir_filter *input;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	union ixgbe_atr_input mask;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	memset(&mask, 0, sizeof(union ixgbe_atr_input));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	if (!ixgbe_flowspec_to_flow_type(fsp,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		err = ixgbe_fdir_set_input_mask_82599(hw, &mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ixgbe_atr_compute_perfect_hash_82599(&input->filter, &mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	err = ixgbe_fdir_write_perfect_filter_82599(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	ixgbe_update_ethtool_fdir_entry(adapter, input, input->sw_idx);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_del_ethtool_fdir_entry(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	err = ixgbe_update_ethtool_fdir_entry(adapter, NULL, (u16)(fsp->location));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_rx_ntuple(struct net_device *dev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_rss_hash_opt(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:static int ixgbe_set_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	struct ixgbe_adapter *adapter = netdev_priv(dev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret = ixgbe_add_ethtool_fdir_entry(adapter, cmd);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret = ixgbe_del_ethtool_fdir_entry(adapter, cmd);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:		ret = ixgbe_set_rss_hash_opt(adapter, cmd);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:struct ethtool_ops ixgbe_ethtool_ops = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_settings		= ixgbe_get_settings,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_settings		= ixgbe_set_settings,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_drvinfo		= ixgbe_get_drvinfo,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_regs_len		= ixgbe_get_regs_len,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_regs		= ixgbe_get_regs,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_wol		= ixgbe_get_wol,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_wol		= ixgbe_set_wol,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.nway_reset		= ixgbe_nway_reset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_eeprom_len		= ixgbe_get_eeprom_len,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_eeprom		= ixgbe_get_eeprom,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_eeprom		= ixgbe_set_eeprom,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_ringparam		= ixgbe_get_ringparam,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_ringparam		= ixgbe_set_ringparam,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_pauseparam		= ixgbe_get_pauseparam,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_pauseparam		= ixgbe_set_pauseparam,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_msglevel		= ixgbe_get_msglevel,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_msglevel		= ixgbe_set_msglevel,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.self_test_count	= ixgbe_diag_test_count,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.self_test		= ixgbe_diag_test,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_strings		= ixgbe_get_strings,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_phys_id		= ixgbe_set_phys_id,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.phys_id		= ixgbe_phys_id,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_stats_count	= ixgbe_get_stats_count,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_sset_count		= ixgbe_get_sset_count,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_ethtool_stats      = ixgbe_get_ethtool_stats,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_coalesce		= ixgbe_get_coalesce,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_coalesce		= ixgbe_set_coalesce,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_rx_csum		= ixgbe_get_rx_csum,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_rx_csum		= ixgbe_set_rx_csum,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_tx_csum		= ixgbe_get_tx_csum,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_tx_csum		= ixgbe_set_tx_csum,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_tso		= ixgbe_set_tso,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_flags		= ixgbe_set_flags,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.get_rxnfc		= ixgbe_get_rxnfc,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_rxnfc		= ixgbe_set_rxnfc,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	.set_rx_ntuple		= ixgbe_set_rx_ntuple,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:void ixgbe_set_ethtool_ops(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_ethtool.c:	SET_ETHTOOL_OPS(netdev, &ixgbe_ethtool_ops);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:#include "ixgbe.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:char ixgbe_driver_name[] = "ixgbe";
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:const char ixgbe_driver_version[] = DRV_VERSION;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:/* ixgbe_pci_tbl - PCI Device ID Table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:const struct pci_device_id ixgbe_pci_tbl[] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_notify_dca(struct notifier_block *, unsigned long event,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	.notifier_call	= ixgbe_notify_dca,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_release_hw_control(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_get_hw_control(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_update_xoff_rx_lfc(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw_stats *hwstats = &adapter->stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if ((hw->fc.current_mode != ixgbe_fc_full) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	    (hw->fc.current_mode != ixgbe_fc_rx_pause))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_update_xoff_received(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw_stats *hwstats = &adapter->stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (adapter->ixgbe_ieee_pfc)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		pfc_en |= !!(adapter->ixgbe_ieee_pfc->pfc_en);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_update_xoff_rx_lfc(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_vlan_stripping_disable - helper to disable vlan tag stripping
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_vlan_stripping_disable(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_vlan_stripping_enable - helper to enable vlan tag stripping
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_vlan_stripping_enable(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_vlan_mode(struct net_device *netdev, struct vlan_group *grp)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_vlan_mode(struct net_device *netdev, u32 features)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//	ixgbe_irq_disable(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//	ixgbe_irq_enable(adapter, true, true);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_vlan_stripping_enable(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_vlan_stripping_disable(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static u8 *ixgbe_addr_list_itr(struct ixgbe_hw *hw, u8 **mc_addr_ptr, u32 *vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = hw->back;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_write_mc_addr_list - write multicast addresses to MTA
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_write_mc_addr_list(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:					ixgbe_addr_list_itr, true);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:						ixgbe_addr_list_itr, false);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_restore_vf_multicasts(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_sync_mac_table(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_available_rars(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter, u8 *addr, u16 queue)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_sync_mac_table(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_flush_sw_mac_table(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_sync_mac_table(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_del_mac_filter_by_index(struct ixgbe_adapter *adapter, int index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_sync_mac_table(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter, u8* addr, u16 queue)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			ixgbe_sync_mac_table(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_write_uc_addr_list - write unicast addresses to RAR table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_write_uc_addr_list(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (netdev_uc_count(netdev) > ixgbe_available_rars(adapter))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			ixgbe_del_mac_filter(adapter, ha->addr, (u16)vfn);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			ixgbe_add_mac_filter(adapter, ha->addr, (u16)vfn);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			ixgbe_del_mac_filter(adapter, ha->da_addr, (u16)vfn);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			ixgbe_add_mac_filter(adapter, ha->da_addr, (u16)vfn);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_set_rx_mode - Unicast, Multicast and Promiscuous mode set
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_set_rx_mode(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			count = ixgbe_write_mc_addr_list(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		count = ixgbe_write_uc_addr_list(adapter, netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (hw->mac.type != ixgbe_mac_82598EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_hpbthresh - calculate high water mark for flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_hpbthresh(struct ixgbe_adapter *adapter, int pb)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_lpbthresh - calculate low water mark for for flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_lpbthresh(struct ixgbe_adapter *adapter, int pb)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_pbthresh_setup - calculate and setup high low water marks
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_pbthresh_setup(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		hw->fc.high_water[i] = ixgbe_hpbthresh(adapter, i);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		hw->fc.low_water[i] = ixgbe_lpbthresh(adapter, i);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_configure(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_configure_pb(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_configure_dcb(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_set_rx_mode(adapter->netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_restore_vlan(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_configure_fcoe(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (adapter->hw.mac.type != ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_init_fdir_signature_82599(&adapter->hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_init_fdir_perfect_82599(&adapter->hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_fdir_filter_restore(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (adapter->hw.mac.type != ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_configure_virtualization(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_configure_tx(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_configure_rx(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static bool ixgbe_is_sfp(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_avago:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_ftl:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_intel:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_passive_tyco:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_passive_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_active_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_sfp_ftl_active:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_phy_nl:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		if (hw->mac.type == ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_clear_vf_stats_counters - Clear out VF stats after reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_clear_vf_stats_counters(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_reinit_locked(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_down(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_up(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_up(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_configure(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_up_complete(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_reset(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_flush_sw_mac_table(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_down(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_disable_rx_queue(adapter, adapter->rx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_irq_disable(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_napi_disable_all(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_ping_all_vfs(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_disable_tx_rx(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	    ((hw->mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	     (hw->mac.type == ixgbe_mac_82599EB)))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_disable_tx_laser(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_clean_all_tx_rings(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_clean_all_rx_rings(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_setup_dca(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_set_dcb_queues: Allocate queues for a DCB-enabled device
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static bool ixgbe_set_dcb_queues(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              struct ixgbe_ring_feature *f;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              ixgbe_dcb_unpack_map_cee(&adapter->dcb_cfg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              struct ixgbe_ring_feature *f;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_set_vmdq_queues: Allocate queues for VMDq devices
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static bool ixgbe_set_vmdq_queues(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:              case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_set_rss_queues: Allocate queues for RSS
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static bool ixgbe_set_rss_queues(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:       struct ixgbe_ring_feature *f;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_set_fcoe_queues: Allocate queues for Fiber Channel over Ethernet (FCoE)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static bool ixgbe_set_fcoe_queues(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:       struct ixgbe_ring_feature *f;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:       ixgbe_set_rss_queues(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_set_num_queues: Allocate queues for device, feature dependent
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_set_num_queues(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:       if (ixgbe_set_vmdq_queues(adapter))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:       if (ixgbe_set_dcb_queues(adapter))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:       if (ixgbe_set_fcoe_queues(adapter))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:       ixgbe_set_rss_queues(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_sw_init - Initialize general software structures (struct ixgbe_adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_sw_init initializes the Adapter private data structure.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_sw_init(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	err = ixgbe_init_shared_code(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	adapter->mac_table = kzalloc(sizeof(struct ixgbe_mac_addr) *
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		hw->phy.smart_speed = ixgbe_smart_speed_on;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		hw->phy.smart_speed = ixgbe_smart_speed_off;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		struct ixgbe_dcb_tc_config *tc;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			tc->pfc = ixgbe_dcb_pfc_disabled;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		adapter->dcb_cfg.rx_pba_cfg = ixgbe_dcb_pba_equal;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		if (hw->mac.type == ixgbe_mac_X540) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//if (hw->mac.type == ixgbe_mac_82599EB ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//    hw->mac.type == ixgbe_mac_X540)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	hw->fc.requested_mode = ixgbe_fc_full;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	hw->fc.current_mode = ixgbe_fc_full;	/* init for ethtool output */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_pbthresh_setup(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_setup_tx_resources - allocate Tx resources (Descriptors)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_setup_tx_resources(struct ixgbe_ring *tx_ring)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	size = sizeof(struct ixgbe_tx_buffer) * tx_ring->count;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	tx_ring->size = tx_ring->count * sizeof(union ixgbe_adv_tx_desc);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_setup_all_tx_resources - allocate all queues Tx resources
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_setup_all_tx_resources(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		err = ixgbe_setup_tx_resources(adapter->tx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_setup_rx_resources - allocate Rx resources (Descriptors)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_setup_rx_resources(struct ixgbe_ring *rx_ring)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	size = sizeof(struct ixgbe_rx_buffer) * rx_ring->count;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	rx_ring->size = rx_ring->count * sizeof(union ixgbe_adv_rx_desc);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_init_rx_page_offset(rx_ring);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_setup_all_rx_resources - allocate all queues Rx resources
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_setup_all_rx_resources(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		err = ixgbe_setup_rx_resources(adapter->rx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_free_tx_resources - Free Tx Resources per Queue
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_free_tx_resources(struct ixgbe_ring *tx_ring)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_clean_tx_ring(tx_ring);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_free_all_tx_resources - Free Tx Resources for All Queues
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_free_all_tx_resources(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			ixgbe_free_tx_resources(adapter->tx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_free_rx_resources - Free Rx Resources
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_free_rx_resources(struct ixgbe_ring *rx_ring)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_clean_rx_ring(rx_ring);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_free_all_rx_resources - Free Rx Resources for All Queues
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_free_all_rx_resources(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:			ixgbe_free_rx_resources(adapter->rx_ring[i]);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_open - Called when a network interface is made active
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_open(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	err = ixgbe_setup_all_tx_resources(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	err = ixgbe_setup_all_rx_resources(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_configure(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	err = ixgbe_request_irq(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_up_complete(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_free_all_rx_resources(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_free_all_tx_resources(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_close - Disables a network interface
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_close(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_down(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_free_irq(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_fdir_filter_exit(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_free_all_tx_resources(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_free_all_rx_resources(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_release_hw_control(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_get_stats - Get System Network Statistics
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:struct net_device_stats *ixgbe_get_stats(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_update_stats(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_update_stats - Update the board statistics counters.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_update_stats(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw_stats *hwstats = &adapter->stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_fcoe *fcoe = &adapter->fcoe;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	printk(KERN_DEBUG "ixgbe_update_stats, tx_queues=%d, rx_queues=%d\n",
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		struct ixgbe_q_vector *q_vector = adapter->q_vector[i];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		struct ixgbe_ring *rx_ring = adapter->rx_ring[i];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		struct ixgbe_ring *tx_ring = adapter->tx_ring[i];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		if ((hw->mac.type == ixgbe_mac_82599EB) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		    (hw->mac.type == ixgbe_mac_X540)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_update_xoff_received(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (hw->mac.type == ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_watchdog_update_link - update the link status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_watchdog_update_link(struct ixgbe_adapter *adapter)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (adapter->ixgbe_ieee_pfc)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		pfc_en |= !!(adapter->ixgbe_ieee_pfc->pfc_en);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		//ixgbe_set_rx_drop_en(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_service_task - manages and runs subtasks
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static void ixgbe_service_task(struct work_struct *work)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//struct ixgbe_adapter *adapter = container_of(work,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//					     struct ixgbe_adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_reset_subtask(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_sfp_detection_subtask(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_sfp_link_config_subtask(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_check_overtemp_subtask(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_watchdog_subtask(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_fdir_reinit_subtask(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_check_hang_subtask(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_service_event_complete(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_set_mac - Change the Ethernet Address of the NIC
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_set_mac(struct net_device *netdev, void *p)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = &adapter->hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_del_mac_filter(adapter, hw->mac.addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ret = ixgbe_add_mac_filter(adapter, hw->mac.addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_ioctl -
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:static int ixgbe_ioctl(struct net_device *netdev, struct ifreq *ifr, int cmd)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_do_reset(struct net_device *netdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = netdev_priv(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_reinit_locked(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_reset(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_probe - Device Initialization Routine
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * @ent: entry in ixgbe_pci_tbl
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_probe initializes an adapter identified by a pci_dev structure.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:int ixgbe_kni_probe(struct pci_dev *pdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = NULL;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_hw *hw = NULL;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	enum ixgbe_mac_type mac_type = ixgbe_mac_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:					   IORESOURCE_MEM), ixgbe_driver_name);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	 * an ixgbe_hw stuct and use ixgbe_set_mac_type.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	hw = vmalloc(sizeof(struct ixgbe_hw));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_set_mac_type(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	 * do this on 82598 devices, ixgbe_set_mac_type does this for us if
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (mac_type == ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (mac_type == ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	netdev = alloc_etherdev_mq(sizeof(struct ixgbe_adapter), indices);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	netdev = alloc_etherdev(sizeof(struct ixgbe_adapter));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_assign_netdev_ops(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_set_ethtool_ops(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	err = ixgbe_sw_init(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_check_options(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	    hw->mac.type == ixgbe_mac_82598EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//	ixgbe_probe_vf(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_get_device_caps(hw, &device_caps);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (ixgbe_validate_mac_addr(netdev->perm_addr)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (ixgbe_validate_mac_addr(netdev->dev_addr)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//setup_timer(&adapter->service_timer, &ixgbe_service_timer,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//INIT_WORK(&adapter->service_task, ixgbe_service_task);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//err = ixgbe_init_interrupt_scheme(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_set_num_queues(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_read_eeprom(hw, 0x2c, &adapter->eeprom_cap);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_read_eeprom(hw, 0x2e, &eeprom_verh);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_read_eeprom(hw, 0x2d, &eeprom_verl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_read_eeprom(hw, 0x17, &offset);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_read_eeprom(hw, offset + 0x84, &eeprom_cfg_blkh);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_read_eeprom(hw, offset + 0x83, &eeprom_cfg_blkl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	    ((hw->mac.ops.get_media_type(hw) == ixgbe_media_type_fiber) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	     (hw->mac.type == ixgbe_mac_82599EB)))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		ixgbe_disable_tx_laser(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		   (hw->bus.speed == ixgbe_bus_speed_5000 ? "5.0GT/s" :
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		   hw->bus.speed == ixgbe_bus_speed_2500 ? "2.5GT/s" :
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		   (hw->bus.width == ixgbe_bus_width_pcie_x8 ? "Width x8" :
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		   hw->bus.width == ixgbe_bus_width_pcie_x4 ? "Width x4" :
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:		   hw->bus.width == ixgbe_bus_width_pcie_x1 ? "Width x1" :
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	err = ixgbe_read_pba_string(hw, part_str, IXGBE_PBANUM_LENGTH);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (ixgbe_is_sfp(hw) && hw->phy.sfp_type != ixgbe_sfp_type_not_present)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	if (((hw->bus.speed == ixgbe_bus_speed_2500) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	     (hw->bus.width <= ixgbe_bus_width_pcie_x4)) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	    (hw->bus.width <= ixgbe_bus_width_pcie_x2)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	ixgbe_set_fw_drv_ver(hw, 0xFF, 0xFF, 0xFF, 0xFF);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_add_sanmac_netdev(netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//if (ixgbe_sysfs_init(adapter))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//if (ixgbe_procfs_init(adapter))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_clear_interrupt_scheme(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	//ixgbe_release_hw_control(adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_remove - Device Removal Routine
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c: * ixgbe_remove is called by the PCI subsystem to alert the driver
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_kni_remove(struct pci_dev *pdev)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = hw->back;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = hw->back;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:void ewarn(struct ixgbe_hw *hw, const char *st, u32 status)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_main.c:	struct ixgbe_adapter *adapter = hw->back;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_init_ops_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:u16 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, u8 *mc_addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:				      ixgbe_mc_addr_itr func, bool clear);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, u8 *addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:				      u32 addr_count, ixgbe_mc_addr_itr func);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_disable_sec_rx_path_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_enable_sec_rx_path_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:void ixgbe_fc_autoneg(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_validate_mac_addr(u8 *mac_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u16 mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u16 mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_set_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_insert_mac_addr_generic(struct ixgbe_hw *hw, u8 *addr, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_set_vlvf_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:			       ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_get_fcoe_boot_status_generic(struct ixgbe_hw *hw, u16 *bs);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int pf);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb, u32 headroom,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:void ixgbe_clear_tx_pending(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.h:s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:#include "ixgbe_82599.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:#include "ixgbe_api.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:#include "ixgbe_common.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:#include "ixgbe_phy.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					 ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:void ixgbe_init_mac_link_ops_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (mac->ops.get_media_type(hw) == ixgbe_media_type_fiber) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				       &ixgbe_disable_tx_laser_multispeed_fiber;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					&ixgbe_enable_tx_laser_multispeed_fiber;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		mac->ops.flap_tx_laser = &ixgbe_flap_tx_laser_multispeed_fiber;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		mac->ops.setup_link = &ixgbe_setup_mac_link_multispeed_fiber;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		if ((ixgbe_get_media_type(hw) == ixgbe_media_type_backplane) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		     (hw->phy.smart_speed == ixgbe_smart_speed_auto ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		      hw->phy.smart_speed == ixgbe_smart_speed_on) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		      !ixgbe_verify_lesm_fw_enabled_82599(hw)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:			mac->ops.setup_link = &ixgbe_setup_mac_link_smartspeed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:			mac->ops.setup_link = &ixgbe_setup_mac_link_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_init_phy_ops_82599 - PHY/SFP specific init
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_init_phy_ops_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_phy_info *phy = &hw->phy;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		phy->ops.read_i2c_byte = &ixgbe_read_i2c_byte_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		phy->ops.write_i2c_byte = &ixgbe_write_i2c_byte_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_init_mac_link_ops_82599(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (hw->phy.sfp_type != ixgbe_sfp_type_unknown)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (mac->ops.get_media_type(hw) == ixgbe_media_type_copper) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		mac->ops.setup_link = &ixgbe_setup_copper_link_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				  &ixgbe_get_copper_link_capabilities_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_tn:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		phy->ops.setup_link = &ixgbe_setup_phy_link_tnx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		phy->ops.check_link = &ixgbe_check_phy_link_tnx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:			     &ixgbe_get_phy_firmware_version_tnx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_setup_sfp_modules_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (hw->phy.sfp_type != ixgbe_sfp_type_unknown) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ixgbe_init_mac_link_ops_82599(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ret_val = ixgbe_get_sfp_init_sequence_offsets(hw, &list_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_init_ops_82599 - Inits func ptrs and MAC type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_init_ops_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_phy_info *phy = &hw->phy;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_init_phy_ops_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ret_val = ixgbe_init_ops_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	phy->ops.identify = &ixgbe_identify_phy_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	phy->ops.init = &ixgbe_init_phy_ops_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.reset_hw = &ixgbe_reset_hw_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.get_media_type = &ixgbe_get_media_type_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				    &ixgbe_get_supported_physical_layer_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.disable_sec_rx_path = &ixgbe_disable_sec_rx_path_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.enable_sec_rx_path = &ixgbe_enable_sec_rx_path_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.enable_rx_dma = &ixgbe_enable_rx_dma_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.read_analog_reg8 = &ixgbe_read_analog_reg8_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.write_analog_reg8 = &ixgbe_write_analog_reg8_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.start_hw = &ixgbe_start_hw_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.get_san_mac_addr = &ixgbe_get_san_mac_addr_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_san_mac_addr = &ixgbe_set_san_mac_addr_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.get_device_caps = &ixgbe_get_device_caps_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.get_wwn_prefix = &ixgbe_get_wwn_prefix_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.get_fcoe_boot_status = &ixgbe_get_fcoe_boot_status_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_vmdq = &ixgbe_set_vmdq_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_vmdq_san_mac = &ixgbe_set_vmdq_san_mac_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.clear_vmdq = &ixgbe_clear_vmdq_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.insert_mac_addr = &ixgbe_insert_mac_addr_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_vfta = &ixgbe_set_vfta_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_vlvf = &ixgbe_set_vlvf_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.clear_vfta = &ixgbe_clear_vfta_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.init_uta_tables = &ixgbe_init_uta_tables_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.setup_sfp = &ixgbe_setup_sfp_modules_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_mac_anti_spoofing = &ixgbe_set_mac_anti_spoofing;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_vlan_anti_spoofing = &ixgbe_set_vlan_anti_spoofing;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.get_link_capabilities = &ixgbe_get_link_capabilities_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.check_link = &ixgbe_check_mac_link_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.setup_rxpba = &ixgbe_set_rxpba_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_init_mac_link_ops_82599(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->max_msix_vectors	= ixgbe_get_pcie_msix_count_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	//hw->mbx.ops.init_params = ixgbe_init_mbx_params_pf;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	eeprom->ops.read = &ixgbe_read_eeprom_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	eeprom->ops.read_buffer = &ixgbe_read_eeprom_buffer_82599;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	mac->ops.set_fw_drv_ver = &ixgbe_set_fw_drv_ver_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					 &ixgbe_get_thermal_sensor_data_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				      &ixgbe_init_thermal_sensor_thresh_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_get_link_capabilities_82599 - Determines link capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_get_link_capabilities_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				      ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core0 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	    hw->phy.sfp_type == ixgbe_sfp_type_1g_cu_core1 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core0 ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	    hw->phy.sfp_type == ixgbe_sfp_type_1g_sx_core1) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_get_media_type_82599 - Get media type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:enum ixgbe_media_type ixgbe_get_media_type_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	enum ixgbe_media_type media_type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_cu_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_tn:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_copper;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_backplane;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_fiber;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_cx4;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_copper;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_fiber_lco;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_fiber_qsfp;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		media_type = ixgbe_media_type_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_start_mac_link_82599 - Setup MAC link settings
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  Configures link settings based on values in the ixgbe_hw struct.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_start_mac_link_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_disable_tx_laser_multispeed_fiber - Disable Tx laser
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:void ixgbe_disable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_enable_tx_laser_multispeed_fiber - Enable Tx laser
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:void ixgbe_enable_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_flap_tx_laser_multispeed_fiber - Flap Tx laser
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:void ixgbe_flap_tx_laser_multispeed_fiber(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ixgbe_disable_tx_laser_multispeed_fiber(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ixgbe_enable_tx_laser_multispeed_fiber(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_setup_mac_link_multispeed_fiber - Set MAC link speed
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_setup_mac_link_multispeed_fiber(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				     ixgbe_link_speed speed, bool autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_link_speed highest_link_speed = IXGBE_LINK_SPEED_UNKNOWN;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	status = ixgbe_get_link_capabilities(hw, &link_speed, &negotiation);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_check_link(hw, &link_speed, &link_up, false);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_82599(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ixgbe_flap_tx_laser(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:			status = ixgbe_check_link(hw, &link_speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_check_link(hw, &link_speed, &link_up, false);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_82599(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ixgbe_flap_tx_laser(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_check_link(hw, &link_speed, &link_up, false);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_multispeed_fiber(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_setup_mac_link_smartspeed - Set MAC link speed using SmartSpeed
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_setup_mac_link_smartspeed(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				    ixgbe_link_speed speed, bool autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_link_speed link_speed = IXGBE_LINK_SPEED_UNKNOWN;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_setup_mac_link_82599(hw, speed, autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:			status = ixgbe_check_link(hw, &link_speed, &link_up,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	status = ixgbe_setup_mac_link_82599(hw, speed, autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		status = ixgbe_check_link(hw, &link_speed, &link_up, false);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	status = ixgbe_setup_mac_link_82599(hw, speed, autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_setup_mac_link_82599 - Set MAC link speed
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_setup_mac_link_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:			       ixgbe_link_speed speed, bool autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_link_speed link_capabilities = IXGBE_LINK_SPEED_UNKNOWN;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	status = ixgbe_get_link_capabilities(hw, &link_capabilities, &autoneg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_setup_copper_link_82599 - Set the PHY autoneg advertised field
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_setup_copper_link_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					 ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_start_mac_link_82599(hw, autoneg_wait_to_complete);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_reset_hw_82599 - Perform hardware reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_reset_hw_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c://	ixgbe_link_speed link_speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_clear_tx_pending(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (ixgbe_validate_mac_addr(hw->mac.san_addr) == 0) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_reinit_fdir_tables_82599 - Reinitialize Flow Director tables.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_fdir_enable_82599 - Initialize Flow Director control registers
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static void ixgbe_fdir_enable_82599(struct ixgbe_hw *hw, u32 fdirctrl)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_init_fdir_signature_82599 - Initialize Flow Director signature filters
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_fdir_enable_82599(hw, fdirctrl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_init_fdir_perfect_82599 - Initialize Flow Director perfect filters
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_fdir_enable_82599(hw, fdirctrl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_atr_compute_sig_hash_82599 - Compute the signature hash
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				     union ixgbe_atr_hash_dword common)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_atr_add_signature_filter_82599 - Adds a signature hash filter
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					  union ixgbe_atr_hash_dword input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					  union ixgbe_atr_hash_dword common,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	fdirhashcmd |= ixgbe_atr_compute_sig_hash_82599(input, common);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_atr_compute_perfect_hash_82599 - Compute the perfect filter hash
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					  union ixgbe_atr_input *input_mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_get_fdirtcpm_82599 - generate a tcp port from atr_input_masks
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static u32 ixgbe_get_fdirtcpm_82599(union ixgbe_atr_input *input_mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:				    union ixgbe_atr_input *input_mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	fdirtcpm = ixgbe_get_fdirtcpm_82599(input_mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					  union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					  union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_fdir_add_perfect_filter_82599 - Adds a perfect filter
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_fdir_add_perfect_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:					union ixgbe_atr_input *input_mask,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	err = ixgbe_fdir_set_input_mask_82599(hw, input_mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ixgbe_atr_compute_perfect_hash_82599(input, input_mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	return ixgbe_fdir_write_perfect_filter_82599(hw, input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_read_analog_reg8_82599 - Reads 8 bit Omer analog register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_read_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 *val)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_write_analog_reg8_82599 - Writes 8 bit Omer analog register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_write_analog_reg8_82599(struct ixgbe_hw *hw, u32 reg, u8 val)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_start_hw_82599 - Prepare hardware for Tx/Rx
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_start_hw_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ret_val = ixgbe_start_hw_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	ret_val = ixgbe_start_hw_gen2(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ret_val = ixgbe_verify_fw_version_82599(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_identify_phy_82599 - Get physical layer module
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_identify_phy_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	status = ixgbe_identify_phy_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		if (hw->mac.ops.get_media_type(hw) == ixgbe_media_type_copper)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:			status = ixgbe_identify_module_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (hw->phy.type == ixgbe_phy_unknown) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		hw->phy.type = ixgbe_phy_none;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (hw->phy.type == ixgbe_phy_sfp_unsupported)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_get_supported_physical_layer_82599 - Returns physical layer type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:u32 ixgbe_get_supported_physical_layer_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_tn:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_cu_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (hw->phy.sfp_type == ixgbe_sfp_type_not_present)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_passive_tyco:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_passive_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_ftl_active:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_active_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_avago:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_ftl:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_intel:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	case ixgbe_phy_sfp_unknown:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_enable_rx_dma_82599 - Enable the Rx DMA unit on 82599
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:s32 ixgbe_enable_rx_dma_82599(struct ixgbe_hw *hw, u32 regval)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_verify_fw_version_82599 - verify fw version for 82599
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_verify_fw_version_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if (hw->phy.media_type != ixgbe_media_type_fiber) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_verify_lesm_fw_enabled_82599 - Checks LESM FW module state.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:bool ixgbe_verify_lesm_fw_enabled_82599(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_read_eeprom_buffer_82599 - Read EEPROM word(s) using
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_read_eeprom_buffer_82599(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if ((eeprom->type == ixgbe_eeprom_spi) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ret_val = ixgbe_read_eerd_buffer_generic(hw, offset, words,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ret_val = ixgbe_read_eeprom_buffer_bit_bang_generic(hw, offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_read_eeprom_82599 - Read EEPROM word using
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_read_eeprom_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	if ((eeprom->type == ixgbe_eeprom_spi) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ret_val = ixgbe_read_eerd_generic(hw, offset, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:		ret_val = ixgbe_read_eeprom_bit_bang_generic(hw, offset, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_read_i2c_byte_82599 - Reads 8 bit word over I2C
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_read_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	status = ixgbe_read_i2c_byte_generic(hw, byte_offset, dev_addr, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c: *  ixgbe_write_i2c_byte_82599 - Writes 8 bit word over I2C
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:static s32 ixgbe_write_i2c_byte_82599(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82599.c:	status = ixgbe_write_i2c_byte_generic(hw, byte_offset, dev_addr, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:u32 ixgbe_get_pcie_msix_count_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_fc_enable_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_start_hw_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_set_vmdq_82598(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_set_vfta_82598(struct ixgbe_hw *hw, u32 vlan, u32 vind, bool vlan_on);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_read_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 *val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_write_analog_reg8_82598(struct ixgbe_hw *hw, u32 reg, u8 val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_read_i2c_eeprom_82598(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:u32 ixgbe_get_supported_physical_layer_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:s32 ixgbe_init_phy_ops_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:void ixgbe_set_lan_id_multi_port_pcie_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_82598.h:void ixgbe_set_pcie_completion_timeout(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#include "ixgbe_dcb.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#include "ixgbe_fcoe.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#include "ixgbe_api.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#define PFX "ixgbe: "
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_lro_stats {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h: * ixgbe_lro_header - header format to be aggregated by LRO
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_lrohdr {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_lro_list {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_lro_stats stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_tx_buffer {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	union ixgbe_adv_tx_desc *next_to_watch;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_rx_buffer {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_queue_stats {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_tx_queue_stats {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_rx_queue_stats {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:enum ixgbe_ring_state_t {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_ring {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring *next;	/* pointer to next ring in q_vector */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_q_vector *q_vector; /* backpointer to host q_vector */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:		struct ixgbe_tx_buffer *tx_buffer_info;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:		struct ixgbe_rx_buffer *rx_buffer_info;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_queue_stats stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:		struct ixgbe_tx_queue_stats tx_stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:		struct ixgbe_rx_queue_stats rx_stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:enum ixgbe_ring_f_enum {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_ring_feature {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:static inline unsigned int ixgbe_rx_pg_order(struct ixgbe_ring *ring)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#define ixgbe_rx_pg_order(_ring) 0
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#define ixgbe_rx_pg_size(_ring) (PAGE_SIZE << ixgbe_rx_pg_order(_ring))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#define ixgbe_rx_bufsz(_ring) ((PAGE_SIZE / 2) << ixgbe_rx_pg_order(_ring))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_ring_container {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring *ring;	/* pointer to linked list of rings */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#define ixgbe_for_each_ring(pos, head) \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_q_vector {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_adapter *adapter;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring_container rx, tx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_lro_list lrolist;   /* LRO list for queue vector*/
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring ring[0] ____cacheline_internodealigned_in_smp;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:/* ixgbe_test_staterr - tests bits in Rx descriptor status and error fields */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:static inline __le32 ixgbe_test_staterr(union ixgbe_adv_rx_desc *rx_desc,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:/* ixgbe_desc_unused - calculate if we have unused descriptors */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:static inline u16 ixgbe_desc_unused(struct ixgbe_ring *ring)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	(&(((union ixgbe_adv_rx_desc *)((R)->desc))[i]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	(&(((union ixgbe_adv_tx_desc *)((R)->desc))[i]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	(&(((struct ixgbe_adv_tx_context_desc *)((R)->desc))[i]))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_mac_addr {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_therm_proc_data {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_hw *hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_thermal_diode_data *sensor_data;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_adapter {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct vlan_group *vlgrp; /* must be first, see ixgbe_receive_skb */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring *tx_ring[MAX_TX_QUEUES] ____cacheline_aligned_in_smp;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring *rx_ring[MAX_RX_QUEUES];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_q_vector *q_vector[MAX_MSIX_Q_VECTORS];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ieee_pfc *ixgbe_ieee_pfc;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ieee_ets *ixgbe_ieee_ets;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_dcb_config dcb_cfg;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_dcb_config temp_dcb_cfg;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	enum ixgbe_fc_mode last_lfc_mode;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring_feature ring_feature[RING_F_ARRAY_SIZE];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_lro_stats lro_stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring test_tx_ring;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_ring test_rx_ring;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	/* structs defined in ixgbe_hw.h */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_hw hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_hw_stats stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	union ixgbe_atr_input fdir_mask;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_fcoe fcoe;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_mac_addr *mac_table;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	struct ixgbe_therm_proc_data therm_data[IXGBE_MAX_SENSORS];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_fdir_filter {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:	union ixgbe_atr_input filter;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:enum ixgbe_state_t {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:struct ixgbe_cb {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#define IXGBE_CB(skb) ((struct ixgbe_cb *)(skb)->cb)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:void ixgbe_sysfs_exit(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:int ixgbe_sysfs_init(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:void ixgbe_procfs_exit(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:int ixgbe_procfs_init(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:int ixgbe_procfs_topdir_init(void);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:void ixgbe_procfs_topdir_exit(void);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_copy_dcb_cfg(struct ixgbe_adapter *adapter, int tc_max);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern u8 ixgbe_dcb_txq_to_tc(struct ixgbe_adapter *adapter, u8 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:/* needed by ixgbe_main.c */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_validate_mac_addr(u8 *mc_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_check_options(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_assign_netdev_ops(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:/* needed by ixgbe_ethtool.c */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern char ixgbe_driver_name[];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern const char ixgbe_driver_version[];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_up(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_down(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_reinit_locked(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_reset(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_set_ethtool_ops(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_setup_rx_resources(struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_setup_tx_resources(struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_free_rx_resources(struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_free_tx_resources(struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_configure_rx_ring(struct ixgbe_adapter *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:				    struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_configure_tx_ring(struct ixgbe_adapter *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:				    struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_update_stats(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_init_interrupt_scheme(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_clear_interrupt_scheme(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern bool ixgbe_is_ixgbe(struct pci_dev *pcidev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern netdev_tx_t ixgbe_xmit_frame_ring(struct sk_buff *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:					 struct ixgbe_adapter *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:					 struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_unmap_and_free_tx_resource(struct ixgbe_ring *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:					     struct ixgbe_tx_buffer *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_alloc_rx_buffers(struct ixgbe_ring *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_configure_rscctl(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:				   struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_clear_rscctl(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:			       struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_set_rx_mode(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_write_mc_addr_list(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_setup_tc(struct net_device *dev, u8 tc);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_tx_ctxtdesc(struct ixgbe_ring *, u32, u32, u32, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_do_reset(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_write_eitr(struct ixgbe_q_vector *q_vector);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_disable_rx_queue(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:				   struct ixgbe_ring *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_vlan_stripping_enable(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_vlan_stripping_disable(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_configure_fcoe(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fso(struct ixgbe_ring *tx_ring,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:		     struct ixgbe_tx_buffer *first,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_cleanup_fcoe(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fcoe_ddp(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:			  union ixgbe_adv_rx_desc *rx_desc,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fcoe_ddp_get(struct net_device *netdev, u16 xid,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fcoe_ddp_target(struct net_device *netdev, u16 xid,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fcoe_ddp_put(struct net_device *netdev, u16 xid);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fcoe_enable(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fcoe_disable(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern u8 ixgbe_fcoe_getapp(struct net_device *netdev);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern u8 ixgbe_fcoe_setapp(struct ixgbe_adapter *adapter, u8 up);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_fcoe_get_wwn(struct net_device *netdev, u64 *wwn, int type);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:s32 ixgbe_dcb_hw_ets(struct ixgbe_hw *hw, struct ieee_ets *ets, int max_frame);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_clean_rx_ring(struct ixgbe_ring *rx_ring);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_get_settings(struct net_device *netdev,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_write_uc_addr_list(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_full_sync_mac_table(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_add_mac_filter(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_del_mac_filter(struct ixgbe_adapter *adapter,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern int ixgbe_available_rars(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_vlan_mode(struct net_device *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#ifndef ixgbe_get_netdev_tc_txq
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:#define ixgbe_get_netdev_tc_txq(dev, tc) (&dev->tc_to_txq[tc])
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe.h:extern void ixgbe_set_rx_drop_en(struct ixgbe_adapter *adapter);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:s32 ixgbe_read_mbx(struct ixgbe_hw *, u32 *, u16, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:s32 ixgbe_write_mbx(struct ixgbe_hw *, u32 *, u16, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:s32 ixgbe_read_posted_mbx(struct ixgbe_hw *, u32 *, u16, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:s32 ixgbe_write_posted_mbx(struct ixgbe_hw *, u32 *, u16, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:s32 ixgbe_check_for_msg(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:s32 ixgbe_check_for_ack(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:s32 ixgbe_check_for_rst(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:void ixgbe_init_mbx_ops_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:void ixgbe_init_mbx_params_vf(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_mbx.h:void ixgbe_init_mbx_params_pf(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:#include "ixgbe_common.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:#include "ixgbe_phy.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:#include "ixgbe_api.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_standby_eeprom(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_init_ops_generic - Inits function ptrs
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_init_ops_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	eeprom->ops.init_params = &ixgbe_init_eeprom_params_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		eeprom->ops.read = &ixgbe_read_eerd_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		eeprom->ops.read_buffer = &ixgbe_read_eerd_buffer_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		eeprom->ops.read = &ixgbe_read_eeprom_bit_bang_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:				 &ixgbe_read_eeprom_buffer_bit_bang_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	eeprom->ops.write = &ixgbe_write_eeprom_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	eeprom->ops.write_buffer = &ixgbe_write_eeprom_buffer_bit_bang_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:				      &ixgbe_validate_eeprom_checksum_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	eeprom->ops.update_checksum = &ixgbe_update_eeprom_checksum_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	eeprom->ops.calc_checksum = &ixgbe_calc_eeprom_checksum_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.init_hw = &ixgbe_init_hw_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.start_hw = &ixgbe_start_hw_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.clear_hw_cntrs = &ixgbe_clear_hw_cntrs_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.enable_rx_dma = &ixgbe_enable_rx_dma_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.get_mac_addr = &ixgbe_get_mac_addr_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.stop_adapter = &ixgbe_stop_adapter_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.get_bus_info = &ixgbe_get_bus_info_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.set_lan_id = &ixgbe_set_lan_id_multi_port_pcie;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.acquire_swfw_sync = &ixgbe_acquire_swfw_sync;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.release_swfw_sync = &ixgbe_release_swfw_sync;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.led_on = &ixgbe_led_on_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.led_off = &ixgbe_led_off_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.blink_led_start = &ixgbe_blink_led_start_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.blink_led_stop = &ixgbe_blink_led_stop_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.set_rar = &ixgbe_set_rar_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.clear_rar = &ixgbe_clear_rar_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.init_rx_addrs = &ixgbe_init_rx_addrs_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.update_uc_addr_list = &ixgbe_update_uc_addr_list_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.update_mc_addr_list = &ixgbe_update_mc_addr_list_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.enable_mc = &ixgbe_enable_mc_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.disable_mc = &ixgbe_disable_mc_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	mac->ops.fc_enable = &ixgbe_fc_enable_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_device_supports_autoneg_fc - Check if phy supports autoneg flow
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_device_supports_autoneg_fc(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_setup_fc - Set up flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_setup_fc(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	 * ixgbe_fc_rx_pause because it will cause us to fail at UNH.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->fc.strict_ieee && hw->fc.requested_mode == ixgbe_fc_rx_pause) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw_dbg(hw, "ixgbe_fc_rx_pause not valid in strict IEEE mode\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->fc.requested_mode == ixgbe_fc_default)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->fc.requested_mode = ixgbe_fc_full;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_media_type_fiber:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_media_type_backplane:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_media_type_copper:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_none:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (hw->phy.media_type == ixgbe_media_type_backplane)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		else if (hw->phy.media_type == ixgbe_media_type_copper)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_tx_pause:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (hw->phy.media_type == ixgbe_media_type_backplane) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		} else if (hw->phy.media_type == ixgbe_media_type_copper) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_rx_pause:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_full:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (hw->phy.media_type == ixgbe_media_type_backplane)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		else if (hw->phy.media_type == ixgbe_media_type_copper)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type != ixgbe_mac_X540) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->phy.media_type == ixgbe_media_type_backplane) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	} else if ((hw->phy.media_type == ixgbe_media_type_copper) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		    (ixgbe_device_supports_autoneg_fc(hw) == 0)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_start_hw_generic - Prepare hardware for Tx/Rx
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_start_hw_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ret_val = ixgbe_setup_fc(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_start_hw_gen2 - Init sequence for common device family
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_start_hw_gen2(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_init_hw_generic - Generic hardware initialization
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_init_hw_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_clear_hw_cntrs_generic - Generic clear hardware counters
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_clear_hw_cntrs_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type >= ixgbe_mac_82599EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (hw->mac.type >= ixgbe_mac_82599EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type >= ixgbe_mac_82599EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (hw->mac.type >= ixgbe_mac_82599EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_X540) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_identify_phy(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_read_pba_string_generic - Reads part number string from EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_read_pba_string_generic(struct ixgbe_hw *hw, u8 *pba_num,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_mac_addr_generic - Generic get MAC address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_get_mac_addr_generic(struct ixgbe_hw *hw, u8 *mac_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_bus_info_generic - Generic set PCI bus info
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  Sets the PCI bus info (speed, width, type) within the ixgbe_hw structure
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_get_bus_info_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	hw->bus.type = ixgbe_bus_type_pci_express;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.width = ixgbe_bus_width_pcie_x1;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.width = ixgbe_bus_width_pcie_x2;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.width = ixgbe_bus_width_pcie_x4;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.width = ixgbe_bus_width_pcie_x8;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.width = ixgbe_bus_width_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.speed = ixgbe_bus_speed_2500;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.speed = ixgbe_bus_speed_5000;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.speed = ixgbe_bus_speed_8000;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->bus.speed = ixgbe_bus_speed_unknown;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_lan_id_multi_port_pcie - Set LAN id for PCIe multiple port devices
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_set_lan_id_multi_port_pcie(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_bus_info *bus = &hw->bus;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_stop_adapter_generic - Generic stop Tx/Rx units
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  Sets the adapter_stopped flag within ixgbe_hw struct. Clears interrupts,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_stop_adapter_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	return ixgbe_disable_pcie_master(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_led_on_generic - Turns on the software controllable LEDs.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_led_on_generic(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_led_off_generic - Turns off the software controllable LEDs.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_led_off_generic(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_init_eeprom_params_generic - Initialize EEPROM params
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  Initializes the EEPROM parameters ixgbe_eeprom_info within the
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_hw struct in order to set up EEPROM access.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_init_eeprom_params_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (eeprom->type == ixgbe_eeprom_uninitialized) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		eeprom->type = ixgbe_eeprom_none;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			eeprom->type = ixgbe_eeprom_spi;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_write_eeprom_buffer_bit_bang_generic - Write EEPROM using bit-bang
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_write_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_detect_eeprom_page_size_generic(hw, offset);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		status = ixgbe_write_eeprom_buffer_bit_bang(hw, offset + i,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_write_eeprom_buffer_bit_bang - Writes 16 bit word(s) to EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  If ixgbe_eeprom_update_checksum is not called after this function, the
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_write_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	status = ixgbe_acquire_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (ixgbe_ready_eeprom(hw) != 0) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_standby_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_shift_out_eeprom_bits(hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_standby_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_shift_out_eeprom_bits(hw, write_opcode,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:				ixgbe_shift_out_eeprom_bits(hw, word, 16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_standby_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_release_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_write_eeprom_generic - Writes 16 bit value to EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  If ixgbe_eeprom_update_checksum is not called after this function, the
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_write_eeprom_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	status = ixgbe_write_eeprom_buffer_bit_bang(hw, offset, 1, &data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_read_eeprom_buffer_bit_bang_generic - Read EEPROM using bit-bang
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_read_eeprom_buffer_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		status = ixgbe_read_eeprom_buffer_bit_bang(hw, offset + i,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_read_eeprom_buffer_bit_bang - Read EEPROM using bit-bang
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_read_eeprom_buffer_bit_bang(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	status = ixgbe_acquire_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (ixgbe_ready_eeprom(hw) != 0) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_standby_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_shift_out_eeprom_bits(hw, read_opcode,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_shift_out_eeprom_bits(hw, (u16)((offset + i) * 2),
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			word_in = ixgbe_shift_in_eeprom_bits(hw, 16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_release_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_read_eeprom_bit_bang_generic - Read EEPROM word using bit-bang
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_read_eeprom_bit_bang_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	status = ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_read_eerd_buffer_generic - Read EEPROM word(s) using EERD
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_read_eerd_buffer_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_READ);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_detect_eeprom_page_size_generic - Detect EEPROM page size
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_detect_eeprom_page_size_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	status = ixgbe_write_eeprom_buffer_bit_bang(hw, offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	status = ixgbe_read_eeprom_buffer_bit_bang(hw, offset, 1, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_read_eerd_generic - Read EEPROM word using EERD
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_read_eerd_generic(struct ixgbe_hw *hw, u16 offset, u16 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	return ixgbe_read_eerd_buffer_generic(hw, offset, 1, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_write_eewr_buffer_generic - Write EEPROM word(s) using EEWR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_write_eewr_buffer_generic(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		status = ixgbe_poll_eerd_eewr_done(hw, IXGBE_NVM_POLL_WRITE);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_write_eewr_generic - Write EEPROM word using EEWR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_write_eewr_generic(struct ixgbe_hw *hw, u16 offset, u16 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	return ixgbe_write_eewr_buffer_generic(hw, offset, 1, &data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_poll_eerd_eewr_done - Poll EERD read or EEWR write status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_poll_eerd_eewr_done(struct ixgbe_hw *hw, u32 ee_reg)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_acquire_eeprom - Acquire EEPROM using bit-bang
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_acquire_eeprom(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_eeprom_semaphore - Get hardware semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_get_eeprom_semaphore(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_release_eeprom_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_release_eeprom_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_release_eeprom_semaphore - Release hardware semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom_semaphore(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_ready_eeprom - Polls for EEPROM ready
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_ready_eeprom(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_shift_out_eeprom_bits(hw, IXGBE_EEPROM_RDSR_OPCODE_SPI,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		spi_stat_reg = (u8)ixgbe_shift_in_eeprom_bits(hw, 8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_standby_eeprom(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_standby_eeprom - Returns EEPROM to a "standby" state
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_standby_eeprom(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_shift_out_eeprom_bits - Shift data bits out to the EEPROM.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_shift_out_eeprom_bits(struct ixgbe_hw *hw, u16 data,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_raise_eeprom_clk(hw, &eec);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_lower_eeprom_clk(hw, &eec);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_shift_in_eeprom_bits - Shift data bits in from the EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static u16 ixgbe_shift_in_eeprom_bits(struct ixgbe_hw *hw, u16 count)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_raise_eeprom_clk(hw, &eec);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_lower_eeprom_clk(hw, &eec);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_raise_eeprom_clk - Raises the EEPROM's clock input.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_raise_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_lower_eeprom_clk - Lowers the EEPROM's clock input.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_lower_eeprom_clk(struct ixgbe_hw *hw, u32 *eec)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_release_eeprom - Release EEPROM, release semaphores
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static void ixgbe_release_eeprom(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_calc_eeprom_checksum_generic - Calculates and returns the checksum
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:u16 ixgbe_calc_eeprom_checksum_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_validate_eeprom_checksum_generic - Validate EEPROM checksum
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_validate_eeprom_checksum_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_update_eeprom_checksum_generic - Updates the EEPROM checksum
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_update_eeprom_checksum_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_validate_mac_addr - Validate MAC address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_validate_mac_addr(u8 *mac_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_rar_generic - Set Rx address register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_set_rar_generic(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_clear_rar_generic - Remove Rx address register
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_clear_rar_generic(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_init_rx_addrs_generic - Initializes receive address filters.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_init_rx_addrs_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (ixgbe_validate_mac_addr(hw->mac.addr) ==
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_init_uta_tables(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_add_uc_addr - Adds a secondary unicast address.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_add_uc_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	hw_dbg(hw, "ixgbe_add_uc_addr Complete\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_update_uc_addr_list_generic - Updates MAC list of secondary addresses
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_update_uc_addr_list_generic(struct ixgbe_hw *hw, u8 *addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:				      u32 addr_count, ixgbe_mc_addr_itr next)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_add_uc_addr(hw, addr, vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	hw_dbg(hw, "ixgbe_update_uc_addr_list_generic Complete\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_mta_vector - Determines bit-vector in multicast table to set
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_mta_vector(struct ixgbe_hw *hw, u8 *mc_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_mta - Set bit-vector in multicast table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	vector = ixgbe_mta_vector(hw, mc_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_update_mc_addr_list_generic - Updates MAC list of multicast addresses
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_update_mc_addr_list_generic(struct ixgbe_hw *hw, u8 *mc_addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:				      u32 mc_addr_count, ixgbe_mc_addr_itr next,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_set_mta(hw, next(hw, &mc_addr_list, &vmdq));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	hw_dbg(hw, "ixgbe_update_mc_addr_list_generic Complete\n");
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_enable_mc_generic - Enable multicast address in RAR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_enable_mc_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_addr_filter_info *a = &hw->addr_ctrl;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_disable_mc_generic - Disable multicast address in RAR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_disable_mc_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_addr_filter_info *a = &hw->addr_ctrl;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_fc_enable_generic - Enable flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_fc_enable_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_fc_autoneg(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_none:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_rx_pause:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_tx_pause:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_fc_full:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if ((hw->fc.current_mode & ixgbe_fc_tx_pause) &&
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_negotiate_fc - Negotiate flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_negotiate_fc(struct ixgbe_hw *hw, u32 adv_reg, u32 lp_reg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (hw->fc.requested_mode == ixgbe_fc_full) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			hw->fc.current_mode = ixgbe_fc_full;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			hw->fc.current_mode = ixgbe_fc_rx_pause;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->fc.current_mode = ixgbe_fc_tx_pause;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->fc.current_mode = ixgbe_fc_rx_pause;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		hw->fc.current_mode = ixgbe_fc_none;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_fc_autoneg_fiber - Enable flow control on 1 gig fiber
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_fc_autoneg_fiber(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ret_val =  ixgbe_negotiate_fc(hw, pcs_anadv_reg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_fc_autoneg_backplane - Enable flow control IEEE clause 37
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_fc_autoneg_backplane(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82599EB) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ret_val = ixgbe_negotiate_fc(hw, autoc_reg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_fc_autoneg_copper - Enable flow control IEEE clause 37
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_fc_autoneg_copper(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	return ixgbe_negotiate_fc(hw, (u32)technology_ability_reg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_fc_autoneg - Configure flow control
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_fc_autoneg(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_link_speed speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_media_type_fiber:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ret_val = ixgbe_fc_autoneg_fiber(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_media_type_backplane:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ret_val = ixgbe_fc_autoneg_backplane(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_media_type_copper:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (ixgbe_device_supports_autoneg_fc(hw) == 0)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ret_val = ixgbe_fc_autoneg_copper(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_disable_pcie_master - Disable PCI-express master access
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_disable_pcie_master(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_acquire_swfw_sync - Acquire SWFW semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_acquire_swfw_sync(struct ixgbe_hw *hw, u16 mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		if (ixgbe_get_eeprom_semaphore(hw))
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_release_eeprom_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_release_eeprom_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_release_swfw_sync - Release SWFW semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_release_swfw_sync(struct ixgbe_hw *hw, u16 mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_get_eeprom_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_release_eeprom_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_disable_sec_rx_path_generic - Stops the receive data path
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_disable_sec_rx_path_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_enable_sec_rx_path_generic - Enables the receive data path
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_enable_sec_rx_path_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_enable_rx_dma_generic - Enable the Rx DMA unit
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_enable_rx_dma_generic(struct ixgbe_hw *hw, u32 regval)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_blink_led_start_generic - Blink LED based on index.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_blink_led_start_generic(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_link_speed speed = 0;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_blink_led_stop_generic - Stop blinking LED based on index.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_blink_led_stop_generic(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_san_mac_addr_offset - Get SAN MAC address offset from the EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_get_san_mac_addr_offset(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_san_mac_addr_generic - SAN MAC address retrieval from the EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_get_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_san_mac_addr_generic - Write the SAN MAC address to the EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_set_san_mac_addr_generic(struct ixgbe_hw *hw, u8 *san_mac_addr)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ixgbe_get_san_mac_addr_offset(hw, &san_mac_offset);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_pcie_msix_count_generic - Gets MSI-X vector count
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:u16 ixgbe_get_pcie_msix_count_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_mac_82598EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_mac_82599EB:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	case ixgbe_mac_X540:
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_insert_mac_addr_generic - Find a RAR for this mac address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_insert_mac_addr_generic(struct ixgbe_hw *hw, u8 *addr, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_set_vmdq(hw, rar, vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_set_rar(hw, rar, addr, vmdq, IXGBE_RAH_AV);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ixgbe_clear_vmdq(hw, rar, 0);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_clear_vmdq_generic - Disassociate a VMDq pool index from a rx address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_clear_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_vmdq_generic - Associate a VMDq pool index with a rx address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_set_vmdq_generic(struct ixgbe_hw *hw, u32 rar, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_vmdq_san_mac - Associate default VMDq pool index with a rx address
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_set_vmdq_san_mac_generic(struct ixgbe_hw *hw, u32 vmdq)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_init_uta_tables_generic - Initialize the Unicast Table Array
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_init_uta_tables_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_find_vlvf_slot - find the vlanid or the first empty slot
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_find_vlvf_slot(struct ixgbe_hw *hw, u32 vlan)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_vfta_generic - Set VLAN filter table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_set_vfta_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	 * Call ixgbe_set_vlvf_generic to set VLVFB and VLVF
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	ret_val = ixgbe_set_vlvf_generic(hw, vlan, vind, vlan_on,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_vlvf_generic - Set VLAN Pool Filter
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_set_vlvf_generic(struct ixgbe_hw *hw, u32 vlan, u32 vind,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		vlvf_index = ixgbe_find_vlvf_slot(hw, vlan);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_clear_vfta_generic - Clear VLAN filter table
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_clear_vfta_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_check_mac_link_generic - Determine link and speed status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_check_mac_link_generic(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_wwn_prefix_generic - Get alternative WWNN/WWPN prefix from
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_get_wwn_prefix_generic(struct ixgbe_hw *hw, u16 *wwnn_prefix,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_fcoe_boot_status_generic - Get FCOE boot status from EEPROM
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_get_fcoe_boot_status_generic(struct ixgbe_hw *hw, u16 *bs)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	*bs = ixgbe_fcoe_bootstatus_unavailable;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		*bs = ixgbe_fcoe_bootstatus_enabled;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		*bs = ixgbe_fcoe_bootstatus_disabled;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_mac_anti_spoofing - Enable/Disable MAC anti-spoofing
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_set_mac_anti_spoofing(struct ixgbe_hw *hw, bool enable, int pf)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_vlan_anti_spoofing - Enable/Disable VLAN anti-spoofing
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_set_vlan_anti_spoofing(struct ixgbe_hw *hw, bool enable, int vf)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if (hw->mac.type == ixgbe_mac_82598EB)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_device_caps_generic - Get additional device capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_get_device_caps_generic(struct ixgbe_hw *hw, u16 *device_caps)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_calculate_checksum - Calculate checksum for buffer
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static u8 ixgbe_calculate_checksum(u8 *buffer, u32 length)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_host_interface_command - Issue command to manageability block
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static s32 ixgbe_host_interface_command(struct ixgbe_hw *hw, u32 *buffer,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	u32 hdr_size = sizeof(struct ixgbe_hic_hdr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	buf_len = ((struct ixgbe_hic_hdr *)buffer)->buf_len;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_set_fw_drv_ver_generic - Sends driver version to firmware
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_set_fw_drv_ver_generic(struct ixgbe_hw *hw, u8 maj, u8 min,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_hic_drv_info fw_cmd;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	fw_cmd.hdr.checksum = ixgbe_calculate_checksum((u8 *)&fw_cmd,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		ret_val = ixgbe_host_interface_command(hw, (u32 *)&fw_cmd,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: * ixgbe_set_rxpba_generic - Initialize Rx packet buffer
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_set_rxpba_generic(struct ixgbe_hw *hw, int num_pb, u32 headroom,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:		/* ixgbe_dcb_pba_80_48 strategy weight first half of packet
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: * ixgbe_clear_tx_pending - Clear pending TX work from the PCIe fifo
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:void ixgbe_clear_tx_pending(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static const u8 ixgbe_emc_temp_data[4] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:static const u8 ixgbe_emc_therm_limit[4] = {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_get_thermal_sensor_data - Gathers thermal sensor data
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_get_thermal_sensor_data_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if ((hw->mac.type != ixgbe_mac_82599EB) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:					ixgbe_emc_temp_data[sensor_index],
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c: *  ixgbe_init_thermal_sensor_thresh_generic - Inits thermal sensor thresholds
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:s32 ixgbe_init_thermal_sensor_thresh_generic(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	struct ixgbe_thermal_sensor_data *data = &hw->mac.thermal_sensor_data;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	memset(data, 0, sizeof(struct ixgbe_thermal_sensor_data));
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:	if ((hw->mac.type != ixgbe_mac_82599EB) ||
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_common.c:			ixgbe_emc_therm_limit[sensor_index],
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:#include "ixgbe_x540.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:#include "ixgbe_api.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:#include "ixgbe_common.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:#include "ixgbe_phy.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_init_ops_X540 - Inits func ptrs and MAC type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_init_ops_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	struct ixgbe_mac_info *mac = &hw->mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	struct ixgbe_phy_info *phy = &hw->phy;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ret_val = ixgbe_init_phy_ops_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ret_val = ixgbe_init_ops_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.init_params = &ixgbe_init_eeprom_params_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.read = &ixgbe_read_eerd_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.read_buffer = &ixgbe_read_eerd_buffer_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.write = &ixgbe_write_eewr_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.write_buffer = &ixgbe_write_eewr_buffer_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.update_checksum = &ixgbe_update_eeprom_checksum_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.validate_checksum = &ixgbe_validate_eeprom_checksum_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	eeprom->ops.calc_checksum = &ixgbe_calc_eeprom_checksum_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	phy->ops.init = &ixgbe_init_phy_ops_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.reset_hw = &ixgbe_reset_hw_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.get_media_type = &ixgbe_get_media_type_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:				    &ixgbe_get_supported_physical_layer_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.start_hw = &ixgbe_start_hw_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.get_san_mac_addr = &ixgbe_get_san_mac_addr_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_san_mac_addr = &ixgbe_set_san_mac_addr_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.get_device_caps = &ixgbe_get_device_caps_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.get_wwn_prefix = &ixgbe_get_wwn_prefix_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.get_fcoe_boot_status = &ixgbe_get_fcoe_boot_status_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.acquire_swfw_sync = &ixgbe_acquire_swfw_sync_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.release_swfw_sync = &ixgbe_release_swfw_sync_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.disable_sec_rx_path = &ixgbe_disable_sec_rx_path_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.enable_sec_rx_path = &ixgbe_enable_sec_rx_path_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_vmdq = &ixgbe_set_vmdq_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_vmdq_san_mac = &ixgbe_set_vmdq_san_mac_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.clear_vmdq = &ixgbe_clear_vmdq_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.insert_mac_addr = &ixgbe_insert_mac_addr_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_vfta = &ixgbe_set_vfta_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_vlvf = &ixgbe_set_vlvf_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.clear_vfta = &ixgbe_clear_vfta_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.init_uta_tables = &ixgbe_init_uta_tables_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_mac_anti_spoofing = &ixgbe_set_mac_anti_spoofing;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_vlan_anti_spoofing = &ixgbe_set_vlan_anti_spoofing;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:				&ixgbe_get_copper_link_capabilities_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.setup_link = &ixgbe_setup_mac_link_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.setup_rxpba = &ixgbe_set_rxpba_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.check_link = &ixgbe_check_mac_link_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->max_msix_vectors	= ixgbe_get_pcie_msix_count_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	//hw->mbx.ops.init_params = ixgbe_init_mbx_params_pf;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.blink_led_start = ixgbe_blink_led_start_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.blink_led_stop = ixgbe_blink_led_stop_X540;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	mac->ops.set_fw_drv_ver = &ixgbe_set_fw_drv_ver_generic;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_get_link_capabilities_X540 - Determines link capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_get_link_capabilities_X540(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:				     ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ixgbe_get_copper_link_capabilities_generic(hw, speed, autoneg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_get_media_type_X540 - Get media type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	return ixgbe_media_type_copper;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_setup_mac_link_X540 - Sets the auto advertised capabilities
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:			      ixgbe_link_speed speed, bool autoneg,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_reset_hw_X540 - Perform hardware reset
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ixgbe_clear_tx_pending(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	if (ixgbe_validate_mac_addr(hw->mac.san_addr) == 0) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_start_hw_X540 - Prepare hardware for Tx/Rx
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ret_val = ixgbe_start_hw_generic(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ret_val = ixgbe_start_hw_gen2(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_get_supported_physical_layer_X540 - Returns physical layer type
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:u32 ixgbe_get_supported_physical_layer_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_init_eeprom_params_X540 - Initialize EEPROM params
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  Initializes the EEPROM parameters ixgbe_eeprom_info within the
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_hw struct in order to set up EEPROM access.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	struct ixgbe_eeprom_info *eeprom = &hw->eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	if (eeprom->type == ixgbe_eeprom_uninitialized) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		eeprom->type = ixgbe_flash;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_read_eerd_X540- Read EEPROM word using EERD
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		status = ixgbe_read_eerd_generic(hw, offset, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_read_eerd_buffer_X540- Read EEPROM word(s) using EERD
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		status = ixgbe_read_eerd_buffer_generic(hw, offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_write_eewr_X540 - Write EEPROM word using EEWR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		status = ixgbe_write_eewr_generic(hw, offset, data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_write_eewr_buffer_X540 - Write EEPROM word(s) using EEWR
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		status = ixgbe_write_eewr_buffer_generic(hw, offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_calc_eeprom_checksum_X540 - Calculates and returns the checksum
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  be used internally by function which utilize ixgbe_acquire_swfw_sync_X540.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:u16 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	 * ixgbe_read_eerd_generic
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		if (ixgbe_read_eerd_generic(hw, i, &word) != 0) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		if (ixgbe_read_eerd_generic(hw, i, &pointer) != 0) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		if (ixgbe_read_eerd_generic(hw, pointer, &length) !=
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:			if (ixgbe_read_eerd_generic(hw, j, &word) !=
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_validate_eeprom_checksum_X540 - Validate EEPROM checksum
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		ixgbe_read_eerd_generic(hw, IXGBE_EEPROM_CHECKSUM,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: * ixgbe_update_eeprom_checksum_X540 - Updates the EEPROM checksum and flash
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		status = ixgbe_write_eewr_generic(hw, IXGBE_EEPROM_CHECKSUM,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		status = ixgbe_update_flash_X540(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_update_flash_X540 - Instruct HW to copy EEPROM to Flash device
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static s32 ixgbe_update_flash_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	status = ixgbe_poll_flash_update_done_X540(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	status = ixgbe_poll_flash_update_done_X540(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		status = ixgbe_poll_flash_update_done_X540(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_poll_flash_update_done_X540 - Poll flash update status
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static s32 ixgbe_poll_flash_update_done_X540(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_acquire_swfw_sync_X540 - Acquire SWFW semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		if (ixgbe_get_swfw_sync_semaphore(hw)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:			ixgbe_release_swfw_sync_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:			ixgbe_release_swfw_sync_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		if (ixgbe_get_swfw_sync_semaphore(hw)) {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:		ixgbe_release_swfw_sync_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_release_swfw_sync_X540 - Release SWFW semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ixgbe_get_swfw_sync_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ixgbe_release_swfw_sync_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_get_nvm_semaphore - Get hardware semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static s32 ixgbe_get_swfw_sync_semaphore(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:			ixgbe_release_swfw_sync_semaphore(hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: *  ixgbe_release_nvm_semaphore - Release hardware semaphore
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:static void ixgbe_release_swfw_sync_semaphore(struct ixgbe_hw *hw)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: * ixgbe_blink_led_start_X540 - Blink LED based on index.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:	ixgbe_link_speed speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c: * ixgbe_blink_led_stop_X540 - Stop blinking LED based on index.
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.c:s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index)
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_shared_code(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:extern s32 ixgbe_init_ops_82598(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:extern s32 ixgbe_init_ops_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:extern s32 ixgbe_init_ops_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_mac_type(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_hw(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_reset_hw(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_start_hw(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_clear_hw_cntrs(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:enum ixgbe_media_type ixgbe_get_media_type(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_mac_addr(struct ixgbe_hw *hw, u8 *mac_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_bus_info(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:u32 ixgbe_get_num_of_tx_queues(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:u32 ixgbe_get_num_of_rx_queues(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_stop_adapter(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_read_pba_string(struct ixgbe_hw *hw, u8 *pba_num, u32 pba_num_size);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_identify_phy(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_reset_phy(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_read_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_write_phy_reg(struct ixgbe_hw *hw, u32 reg_addr, u32 device_type,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_setup_phy_link(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_check_phy_link(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:			 ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_setup_phy_link_speed(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:			       ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:void ixgbe_disable_tx_laser(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:void ixgbe_enable_tx_laser(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:void ixgbe_flap_tx_laser(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_setup_link(struct ixgbe_hw *hw, ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_check_link(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_link_capabilities(struct ixgbe_hw *hw, ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_led_on(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_led_off(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_blink_led_start(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_blink_led_stop(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_eeprom_params(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_write_eeprom(struct ixgbe_hw *hw, u16 offset, u16 data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_write_eeprom_buffer(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_read_eeprom(struct ixgbe_hw *hw, u16 offset, u16 *data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_read_eeprom_buffer(struct ixgbe_hw *hw, u16 offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_validate_eeprom_checksum(struct ixgbe_hw *hw, u16 *checksum_val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_update_eeprom_checksum(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_insert_mac_addr(struct ixgbe_hw *hw, u8 *addr, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_rar(struct ixgbe_hw *hw, u32 index, u8 *addr, u32 vmdq,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_clear_rar(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_vmdq_san_mac(struct ixgbe_hw *hw, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_clear_vmdq(struct ixgbe_hw *hw, u32 rar, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_rx_addrs(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:u32 ixgbe_get_num_rx_addrs(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_update_uc_addr_list(struct ixgbe_hw *hw, u8 *addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:			      u32 addr_count, ixgbe_mc_addr_itr func);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_update_mc_addr_list(struct ixgbe_hw *hw, u8 *mc_addr_list,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:			      u32 mc_addr_count, ixgbe_mc_addr_itr func,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:void ixgbe_add_uc_addr(struct ixgbe_hw *hw, u8 *addr_list, u32 vmdq);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_enable_mc(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_disable_mc(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_clear_vfta(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_vfta(struct ixgbe_hw *hw, u32 vlan,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_vlvf(struct ixgbe_hw *hw, u32 vlan, u32 vind,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_fc_enable(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_fw_drv_ver(struct ixgbe_hw *hw, u8 maj, u8 min, u8 build,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_thermal_sensor_data(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_thermal_sensor_thresh(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:void ixgbe_set_mta(struct ixgbe_hw *hw, u8 *mc_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_phy_firmware_version(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_read_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 *val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_write_analog_reg8(struct ixgbe_hw *hw, u32 reg, u8 val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_uta_tables(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_read_i2c_eeprom(struct ixgbe_hw *hw, u8 byte_offset, u8 *eeprom_data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:u32 ixgbe_get_supported_physical_layer(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_enable_rx_dma(struct ixgbe_hw *hw, u32 regval);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_disable_sec_rx_path(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_enable_sec_rx_path(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_reinit_fdir_tables_82599(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_fdir_signature_82599(struct ixgbe_hw *hw, u32 fdirctrl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_init_fdir_perfect_82599(struct ixgbe_hw *hw, u32 fdirctrl);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_fdir_add_signature_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:					  union ixgbe_atr_hash_dword input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:					  union ixgbe_atr_hash_dword common,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_fdir_set_input_mask_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:				    union ixgbe_atr_input *input_mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_fdir_write_perfect_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:					  union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_fdir_erase_perfect_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:					  union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_fdir_add_perfect_filter_82599(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:					union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:					union ixgbe_atr_input *mask,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:void ixgbe_atr_compute_perfect_hash_82599(union ixgbe_atr_input *input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:					  union ixgbe_atr_input *mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:u32 ixgbe_atr_compute_sig_hash_82599(union ixgbe_atr_hash_dword input,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:				     union ixgbe_atr_hash_dword common);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_read_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_write_i2c_byte(struct ixgbe_hw *hw, u8 byte_offset, u8 dev_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_write_i2c_eeprom(struct ixgbe_hw *hw, u8 byte_offset, u8 eeprom_data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_set_san_mac_addr(struct ixgbe_hw *hw, u8 *san_mac_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_device_caps(struct ixgbe_hw *hw, u16 *device_caps);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_acquire_swfw_semaphore(struct ixgbe_hw *hw, u16 mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:void ixgbe_release_swfw_semaphore(struct ixgbe_hw *hw, u16 mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_wwn_prefix(struct ixgbe_hw *hw, u16 *wwnn_prefix,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_api.h:s32 ixgbe_get_fcoe_boot_status(struct ixgbe_hw *hw, u16 *bs);
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.h:/* enable NAPI for ixgbe by default */
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.h:#define adapter_struct ixgbe_adapter
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.h:#define adapter_q_vector ixgbe_q_vector
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.h: * Node module parameter of ixgbe.
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.h:#undef ixgbe_get_netdev_tc_txq
./librte_eal/linuxapp/kni/ethtool/ixgbe/kcompat.h:#define ixgbe_get_netdev_tc_txq(dev, tc) (&netdev_extended(dev)->qos_data.tc_to_txq[tc])
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_init_phy_ops_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:bool ixgbe_validate_phy_addr(struct ixgbe_hw *hw, u32 phy_addr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:enum ixgbe_phy_type ixgbe_get_phy_type_from_id(u32 phy_id);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_get_phy_id(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_identify_phy_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_reset_phy_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_read_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_write_phy_reg_generic(struct ixgbe_hw *hw, u32 reg_addr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_setup_phy_link_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_setup_phy_link_speed_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:				       ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_get_copper_link_capabilities_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:					       ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_check_phy_link_tnx(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:			     ixgbe_link_speed *speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_setup_phy_link_tnx(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_get_phy_firmware_version_tnx(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_get_phy_firmware_version_generic(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_reset_phy_nl(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_identify_module_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_identify_sfp_module_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_identify_qsfp_module_generic(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_get_sfp_init_sequence_offsets(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_tn_check_overtemp(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_read_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_write_i2c_byte_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_read_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:s32 ixgbe_write_i2c_eeprom_generic(struct ixgbe_hw *hw, u8 byte_offset,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_phy.h:void ixgbe_i2c_bus_clear(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:#include "ixgbe_type.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_get_link_capabilities_X540(struct ixgbe_hw *hw,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:				     ixgbe_link_speed *speed, bool *autoneg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:enum ixgbe_media_type ixgbe_get_media_type_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_setup_mac_link_X540(struct ixgbe_hw *hw, ixgbe_link_speed speed,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_reset_hw_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_start_hw_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:u32 ixgbe_get_supported_physical_layer_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_init_eeprom_params_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_read_eerd_X540(struct ixgbe_hw *hw, u16 offset, u16 *data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_read_eerd_buffer_X540(struct ixgbe_hw *hw, u16 offset, u16 words,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_write_eewr_X540(struct ixgbe_hw *hw, u16 offset, u16 data);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_write_eewr_buffer_X540(struct ixgbe_hw *hw, u16 offset, u16 words,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_update_eeprom_checksum_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_validate_eeprom_checksum_X540(struct ixgbe_hw *hw, u16 *checksum_val);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:u16 ixgbe_calc_eeprom_checksum_X540(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_acquire_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:void ixgbe_release_swfw_sync_X540(struct ixgbe_hw *hw, u16 mask);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_blink_led_start_X540(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_x540.h:s32 ixgbe_blink_led_stop_X540(struct ixgbe_hw *hw, u32 index);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:#include "ixgbe_osdep.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_thermal_diode_data {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_thermal_sensor_data {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_thermal_diode_data sensor[IXGBE_MAX_SENSORS];
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h: * supported by all ixgbe hardware
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_fdir_pballoc_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_hic_hdr {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_hic_drv_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_hic_hdr hdr;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_legacy_tx_desc {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:union ixgbe_adv_tx_desc {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_legacy_rx_desc {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:union ixgbe_adv_rx_desc {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_adv_tx_context_desc {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:typedef u32 ixgbe_autoneg_advertised;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:typedef u32 ixgbe_link_speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:typedef u32 ixgbe_physical_layer;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_atr_flow_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:union ixgbe_atr_input {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:union ixgbe_atr_hash_dword {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_fcoe_boot_status {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fcoe_bootstatus_disabled = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fcoe_bootstatus_enabled = 1,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fcoe_bootstatus_unavailable = 0xFFFF
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_eeprom_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_eeprom_uninitialized = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_eeprom_spi,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_flash,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_eeprom_none /* No NVM support */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_mac_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_mac_unknown = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_mac_82598EB,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_mac_82599EB,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_mac_X540,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_num_macs
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_phy_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_unknown = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_none,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_tn,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_aq,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_cu_unknown,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_qt,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_xaui,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_nl,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_passive_tyco,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_passive_unknown,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_active_unknown,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_avago,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_ftl,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_ftl_active,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_unknown,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_intel,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_sfp_unsupported, /*Enforce bit set with unsupported module*/
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_phy_generic
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_sfp_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_da_cu = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_sr = 1,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_lr = 2,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_da_cu_core0 = 3,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_da_cu_core1 = 4,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_srlr_core0 = 5,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_srlr_core1 = 6,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_da_act_lmt_core0 = 7,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_da_act_lmt_core1 = 8,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_1g_cu_core0 = 9,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_1g_cu_core1 = 10,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_1g_sx_core0 = 11,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_1g_sx_core1 = 12,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_not_present = 0xFFFE,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_sfp_type_unknown = 0xFFFF
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_media_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_unknown = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_fiber,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_fiber_qsfp,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_fiber_lco,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_copper,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_backplane,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_cx4,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_media_type_virtual
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_fc_mode {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fc_none = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fc_rx_pause,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fc_tx_pause,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fc_full,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_fc_default
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_smart_speed {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_smart_speed_auto = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_smart_speed_on,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_smart_speed_off
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_bus_type {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_type_unknown = 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_type_pci,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_type_pcix,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_type_pci_express,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_type_reserved
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_bus_speed {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_unknown	= 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_33	= 33,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_66	= 66,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_100	= 100,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_120	= 120,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_133	= 133,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_2500	= 2500,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_5000	= 5000,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_8000	= 8000,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_speed_reserved
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:enum ixgbe_bus_width {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_unknown	= 0,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_pcie_x1	= 1,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_pcie_x2	= 2,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_pcie_x4	= 4,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_pcie_x8	= 8,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_32	= 32,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_64	= 64,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_bus_width_reserved
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_addr_filter_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_bus_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_bus_speed speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_bus_width width;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_bus_type type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_fc_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_fc_mode current_mode; /* FC mode in effect */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_fc_mode requested_mode; /* FC mode requested by caller */
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_hw_stats {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:typedef u8* (*ixgbe_mc_addr_itr) (struct ixgbe_hw *hw, u8 **mc_addr_ptr,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_eeprom_operations {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*init_params)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*read)(struct ixgbe_hw *, u16, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*read_buffer)(struct ixgbe_hw *, u16, u16, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*write)(struct ixgbe_hw *, u16, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*write_buffer)(struct ixgbe_hw *, u16, u16, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*validate_checksum)(struct ixgbe_hw *, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*update_checksum)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	u16 (*calc_checksum)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_mac_operations {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*init_hw)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*reset_hw)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*start_hw)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*clear_hw_cntrs)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_media_type (*get_media_type)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	u32 (*get_supported_physical_layer)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_mac_addr)(struct ixgbe_hw *, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_san_mac_addr)(struct ixgbe_hw *, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_san_mac_addr)(struct ixgbe_hw *, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_device_caps)(struct ixgbe_hw *, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_wwn_prefix)(struct ixgbe_hw *, u16 *, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_fcoe_boot_status)(struct ixgbe_hw *, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*stop_adapter)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_bus_info)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*set_lan_id)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*read_analog_reg8)(struct ixgbe_hw*, u32, u8*);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*write_analog_reg8)(struct ixgbe_hw*, u32, u8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*setup_sfp)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*enable_rx_dma)(struct ixgbe_hw *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*disable_sec_rx_path)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*enable_sec_rx_path)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*acquire_swfw_sync)(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*release_swfw_sync)(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*disable_tx_laser)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*enable_tx_laser)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*flap_tx_laser)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*setup_link)(struct ixgbe_hw *, ixgbe_link_speed, bool, bool);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *, bool);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_link_capabilities)(struct ixgbe_hw *, ixgbe_link_speed *,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*setup_rxpba)(struct ixgbe_hw *, int, u32, int);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*led_on)(struct ixgbe_hw *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*led_off)(struct ixgbe_hw *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*blink_led_start)(struct ixgbe_hw *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*blink_led_stop)(struct ixgbe_hw *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_rar)(struct ixgbe_hw *, u32, u8 *, u32, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_uc_addr)(struct ixgbe_hw *, u32, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*clear_rar)(struct ixgbe_hw *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*insert_mac_addr)(struct ixgbe_hw *, u8 *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_vmdq)(struct ixgbe_hw *, u32, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_vmdq_san_mac)(struct ixgbe_hw *, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*clear_vmdq)(struct ixgbe_hw *, u32, u32);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*init_rx_addrs)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*update_uc_addr_list)(struct ixgbe_hw *, u8 *, u32,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:				   ixgbe_mc_addr_itr);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*update_mc_addr_list)(struct ixgbe_hw *, u8 *, u32,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:				   ixgbe_mc_addr_itr, bool clear);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*enable_mc)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*disable_mc)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*clear_vfta)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_vfta)(struct ixgbe_hw *, u32, u32, bool);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_vlvf)(struct ixgbe_hw *, u32, u32, bool, bool *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*init_uta_tables)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*set_mac_anti_spoofing)(struct ixgbe_hw *, bool, int);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*set_vlan_anti_spoofing)(struct ixgbe_hw *, bool, int);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*fc_enable)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*set_fw_drv_ver)(struct ixgbe_hw *, u8, u8, u8, u8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_thermal_sensor_data)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*init_thermal_sensor_thresh)(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_phy_operations {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*identify)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*identify_sfp)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*init)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*reset)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*read_reg)(struct ixgbe_hw *, u32, u32, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*write_reg)(struct ixgbe_hw *, u32, u32, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*setup_link)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*setup_link_speed)(struct ixgbe_hw *, ixgbe_link_speed, bool,
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*check_link)(struct ixgbe_hw *, ixgbe_link_speed *, bool *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*get_firmware_version)(struct ixgbe_hw *, u16 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*read_i2c_byte)(struct ixgbe_hw *, u8, u8, u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*write_i2c_byte)(struct ixgbe_hw *, u8, u8, u8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*read_i2c_eeprom)(struct ixgbe_hw *, u8 , u8 *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*write_i2c_eeprom)(struct ixgbe_hw *, u8, u8);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*i2c_bus_clear)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32 (*check_overtemp)(struct ixgbe_hw *);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_eeprom_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_eeprom_operations ops;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_eeprom_type type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_mac_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_mac_operations ops;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_mac_type type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_thermal_sensor_data  thermal_sensor_data;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_phy_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_phy_operations ops;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_phy_type type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_sfp_type sfp_type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_media_type media_type;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	ixgbe_autoneg_advertised autoneg_advertised;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	enum ixgbe_smart_speed smart_speed;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:#include "ixgbe_mbx.h"
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_mbx_operations {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	void (*init_params)(struct ixgbe_hw *hw);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32  (*read)(struct ixgbe_hw *, u32 *, u16,  u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32  (*write)(struct ixgbe_hw *, u32 *, u16, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32  (*read_posted)(struct ixgbe_hw *, u32 *, u16,  u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32  (*write_posted)(struct ixgbe_hw *, u32 *, u16, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32  (*check_for_msg)(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32  (*check_for_ack)(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	s32  (*check_for_rst)(struct ixgbe_hw *, u16);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_mbx_stats {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_mbx_info {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_mbx_operations ops;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_mbx_stats stats;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:struct ixgbe_hw {
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_mac_info mac;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_addr_filter_info addr_ctrl;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_fc_info fc;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_phy_info phy;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_eeprom_info eeprom;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_bus_info bus;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:	struct ixgbe_mbx_info mbx;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_type.h:#define ixgbe_call_func(hw, func, params, error) \
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_osdep.h:/* glue for the OS independent part of ixgbe
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_osdep.h:struct ixgbe_hw;
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_osdep.h:extern u16 ixgbe_read_pci_cfg_word(struct ixgbe_hw *hw, u32 reg);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_osdep.h:extern void ixgbe_write_pci_cfg_word(struct ixgbe_hw *hw, u32 reg, u16 value);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_osdep.h:extern void ewarn(struct ixgbe_hw *hw, const char *str, u32 status);
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_osdep.h:#define IXGBE_READ_PCIE_WORD ixgbe_read_pci_cfg_word
./librte_eal/linuxapp/kni/ethtool/ixgbe/ixgbe_osdep.h:#define IXGBE_WRITE_PCIE_WORD ixgbe_write_pci_cfg_word
./librte_eal/linuxapp/kni/Makefile:MODULE_CFLAGS += -I$(RTE_OUTPUT)/include -I$(SRCDIR)/ethtool/ixgbe -I$(SRCDIR)/ethtool/igb
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_main.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_api.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_common.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_ethtool.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_82599.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_82598.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_x540.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/ixgbe_phy.c
./librte_eal/linuxapp/kni/Makefile:SRCS-$(CONFIG_RTE_KNI_KMOD_ETHTOOL) += ethtool/ixgbe/kcompat.c
./librte_eal/linuxapp/kni/kni_misc.c:extern const struct pci_device_id ixgbe_pci_tbl[];
./librte_eal/linuxapp/kni/kni_misc.c:		if (pci_match_id(ixgbe_pci_tbl, dev->pci_dev))
./librte_eal/linuxapp/kni/kni_misc.c:			ixgbe_kni_remove(dev->pci_dev);
./librte_eal/linuxapp/kni/kni_misc.c:			if (pci_match_id(ixgbe_pci_tbl, found_pci))
./librte_eal/linuxapp/kni/kni_misc.c:				ret = ixgbe_kni_probe(found_pci, &lad_dev);
./librte_eal/linuxapp/kni/kni_dev.h:int ixgbe_kni_probe(struct pci_dev *pdev, struct net_device **lad_dev);
./librte_eal/linuxapp/kni/kni_dev.h:void ixgbe_kni_remove(struct pci_dev *pdev);
